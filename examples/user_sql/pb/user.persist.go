// This file is generated by protoc-gen-persist
// Source File: pb/user.proto
// DO NOT EDIT !
package pb

import (
	sql "database/sql"
	driver "database/sql/driver"
	fmt "fmt"
	io "io"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type PersistTx interface {
	Commit() error
	Rollback() error
	Runnable
}

func NopPersistTx(r Runnable) (PersistTx, error) {
	return &ignoreTx{r}, nil
}

type ignoreTx struct {
	r Runnable
}

func (this *ignoreTx) Commit() error   { return nil }
func (this *ignoreTx) Rollback() error { return nil }
func (this *ignoreTx) QueryContext(ctx context.Context, x string, ys ...interface{}) (*sql.Rows, error) {
	return this.r.QueryContext(ctx, x, ys...)
}
func (this *ignoreTx) ExecContext(ctx context.Context, x string, ys ...interface{}) (sql.Result, error) {
	return this.r.ExecContext(ctx, x, ys...)
}

type Runnable interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func DefaultClientStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return db.BeginTx(ctx, nil)
}
func DefaultServerStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultBidiStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultUnaryPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}

type alwaysScanner struct {
	i *interface{}
}

func (s *alwaysScanner) Scan(src interface{}) error {
	s.i = &src
	return nil
}

type scanable interface {
	Scan(...interface{}) error
	Columns() ([]string, error)
}

// Queries_UServ holds all the queries found the proto service option as methods
type Queries_UServ struct {
	opts Opts_UServ
}

// QueriesUServ returns all the known 'SQL' queires for the 'UServ' service.
// If no opts are provided default implementations are used.
func QueriesUServ(opts ...Opts_UServ) *Queries_UServ {
	var myOpts Opts_UServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsUServ(&DefaultHooks_UServ{}, &DefaultTypeMappings_UServ{})
	}
	return &Queries_UServ{
		opts: myOpts,
	}
}

// CreateUsersTable returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'create_users_table' on the database
// when executed
func (this *Queries_UServ) CreateUsersTable(ctx context.Context, db Runnable) *Query_UServ_CreateUsersTable {
	return &Query_UServ_CreateUsersTable{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_CreateUsersTable (future doc string needed)
type Query_UServ_CreateUsersTable struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_CreateUsersTable) QueryInType_Empty()  {}
func (this *Query_UServ_CreateUsersTable) QueryOutType_Empty() {}

// Executes the query 'create_users_table' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_CreateUsersTable) Execute(x In_UServ_CreateUsersTable) *Iter_UServ_CreateUsersTable {
	var setupErr error
	params := []interface{}{}
	result := &Iter_UServ_CreateUsersTable{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "CREATE TABLE users(id integer PRIMARY KEY, name VARCHAR(50), friends BYTEA, created_on VARCHAR(50))", params...)
	return result
}

// InsertUsers returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'insert_users' on the database
// when executed
func (this *Queries_UServ) InsertUsers(ctx context.Context, db Runnable) *Query_UServ_InsertUsers {
	return &Query_UServ_InsertUsers{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_InsertUsers (future doc string needed)
type Query_UServ_InsertUsers struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_InsertUsers) QueryInType_User()   {}
func (this *Query_UServ_InsertUsers) QueryOutType_Empty() {}

// Executes the query 'insert_users' with parameters retrieved from x.
// Fields used: [id name friends created_on]
func (this *Query_UServ_InsertUsers) Execute(x In_UServ_InsertUsers) *Iter_UServ_InsertUsers {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
		func() (out interface{}) {
			out = x.GetName()
			return
		}(),
		func() (out interface{}) {
			raw, err := proto.Marshal(x.GetFriends())
			if err != nil {
				setupErr = err
			}
			out = raw
			return
		}(),
		func() (out interface{}) {
			mapper := this.opts.MAPPINGS.TimestampTimestamp()
			out = mapper.ToSql(x.GetCreatedOn())
			return
		}(),
	}
	result := &Iter_UServ_InsertUsers{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "INSERT INTO users (id, name, friends, created_on) VALUES ($1, $2, $3, $4)", params...)
	return result
}

// GetAllUsers returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'get_all_users' on the database
// when executed
func (this *Queries_UServ) GetAllUsers(ctx context.Context, db Runnable) *Query_UServ_GetAllUsers {
	return &Query_UServ_GetAllUsers{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_GetAllUsers (future doc string needed)
type Query_UServ_GetAllUsers struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_GetAllUsers) QueryInType_Empty() {}
func (this *Query_UServ_GetAllUsers) QueryOutType_User() {}

// Executes the query 'get_all_users' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_GetAllUsers) Execute(x In_UServ_GetAllUsers) *Iter_UServ_GetAllUsers {
	var setupErr error
	params := []interface{}{}
	result := &Iter_UServ_GetAllUsers{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id, name, friends, created_on FROM users", params...)
	return result
}

// SelectUserById returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'select_user_by_id' on the database
// when executed
func (this *Queries_UServ) SelectUserById(ctx context.Context, db Runnable) *Query_UServ_SelectUserById {
	return &Query_UServ_SelectUserById{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_SelectUserById (future doc string needed)
type Query_UServ_SelectUserById struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_SelectUserById) QueryInType_User()  {}
func (this *Query_UServ_SelectUserById) QueryOutType_User() {}

// Executes the query 'select_user_by_id' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_UServ_SelectUserById) Execute(x In_UServ_SelectUserById) *Iter_UServ_SelectUserById {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_UServ_SelectUserById{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id, name, friends, created_on FROM users WHERE id = $1", params...)
	return result
}

// UpdateUserName returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'update_user_name' on the database
// when executed
func (this *Queries_UServ) UpdateUserName(ctx context.Context, db Runnable) *Query_UServ_UpdateUserName {
	return &Query_UServ_UpdateUserName{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_UpdateUserName (future doc string needed)
type Query_UServ_UpdateUserName struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_UpdateUserName) QueryInType_User()  {}
func (this *Query_UServ_UpdateUserName) QueryOutType_User() {}

// Executes the query 'update_user_name' with parameters retrieved from x.
// Fields used: [name id]
func (this *Query_UServ_UpdateUserName) Execute(x In_UServ_UpdateUserName) *Iter_UServ_UpdateUserName {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetName()
			return
		}(),
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_UServ_UpdateUserName{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "Update users set name = $1 WHERE id = $2  RETURNING id, name, friends, created_on", params...)
	return result
}

// UpdateNameToFoo returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'update_name_to_foo' on the database
// when executed
func (this *Queries_UServ) UpdateNameToFoo(ctx context.Context, db Runnable) *Query_UServ_UpdateNameToFoo {
	return &Query_UServ_UpdateNameToFoo{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_UpdateNameToFoo (future doc string needed)
type Query_UServ_UpdateNameToFoo struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_UpdateNameToFoo) QueryInType_User()   {}
func (this *Query_UServ_UpdateNameToFoo) QueryOutType_Empty() {}

// Executes the query 'update_name_to_foo' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_UServ_UpdateNameToFoo) Execute(x In_UServ_UpdateNameToFoo) *Iter_UServ_UpdateNameToFoo {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_UServ_UpdateNameToFoo{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "Update users set name = 'foo' WHERE id = $1", params...)
	return result
}

// GetFriends returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'get_friends' on the database
// when executed
func (this *Queries_UServ) GetFriends(ctx context.Context, db Runnable) *Query_UServ_GetFriends {
	return &Query_UServ_GetFriends{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_GetFriends (future doc string needed)
type Query_UServ_GetFriends struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_GetFriends) QueryInType_FriendsReq() {}
func (this *Query_UServ_GetFriends) QueryOutType_User()      {}

// Executes the query 'get_friends' with parameters retrieved from x.
// Fields used: [names]
func (this *Query_UServ_GetFriends) Execute(x In_UServ_GetFriends) *Iter_UServ_GetFriends {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			mapper := this.opts.MAPPINGS.SliceStringParam()
			out = mapper.ToSql(x.GetNames())
			return
		}(),
	}
	result := &Iter_UServ_GetFriends{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id, name, friends, created_on FROM users WHERE name = ANY($1)", params...)
	return result
}

// Drop returns a new struct wrapping the current Opts_UServ
// that will perform 'UServ' services 'drop' on the database
// when executed
func (this *Queries_UServ) Drop(ctx context.Context, db Runnable) *Query_UServ_Drop {
	return &Query_UServ_Drop{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_Drop (future doc string needed)
type Query_UServ_Drop struct {
	opts Opts_UServ
	db   Runnable
	ctx  context.Context
}

func (this *Query_UServ_Drop) QueryInType_Empty()  {}
func (this *Query_UServ_Drop) QueryOutType_Empty() {}

// Executes the query 'drop' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_Drop) Execute(x In_UServ_Drop) *Iter_UServ_Drop {
	var setupErr error
	params := []interface{}{}
	result := &Iter_UServ_Drop{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "drop table users", params...)
	return result
}

type Iter_UServ_CreateUsersTable struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_CreateUsersTable) IterOutTypeEmpty() {}
func (this *Iter_UServ_CreateUsersTable) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_CreateUsersTable) Each(fun func(*Row_UServ_CreateUsersTable) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_CreateUsersTable) One() *Row_UServ_CreateUsersTable {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_CreateUsersTable{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_CreateUsersTable{err: fmt.Errorf("expected exactly 1 result from query 'CreateUsersTable' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_CreateUsersTable) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'CreateUsersTable'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_CreateUsersTable) Next() (*Row_UServ_CreateUsersTable, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_CreateUsersTable{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_CreateUsersTable{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_CreateUsersTable{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_UServ_CreateUsersTable{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_CreateUsersTable{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_CreateUsersTable) Slice() []*Row_UServ_CreateUsersTable {
	var results []*Row_UServ_CreateUsersTable
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_CreateUsersTable) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_InsertUsers struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_InsertUsers) IterOutTypeEmpty() {}
func (this *Iter_UServ_InsertUsers) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_InsertUsers) Each(fun func(*Row_UServ_InsertUsers) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_InsertUsers) One() *Row_UServ_InsertUsers {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_InsertUsers{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_InsertUsers{err: fmt.Errorf("expected exactly 1 result from query 'InsertUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_InsertUsers) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'InsertUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_InsertUsers) Next() (*Row_UServ_InsertUsers, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_InsertUsers{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_InsertUsers{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_InsertUsers{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_UServ_InsertUsers{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_InsertUsers{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_InsertUsers) Slice() []*Row_UServ_InsertUsers {
	var results []*Row_UServ_InsertUsers
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_InsertUsers) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_GetAllUsers struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_GetAllUsers) IterOutTypeUser() {}
func (this *Iter_UServ_GetAllUsers) IterInTypeEmpty() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_GetAllUsers) Each(fun func(*Row_UServ_GetAllUsers) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_GetAllUsers) One() *Row_UServ_GetAllUsers {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_GetAllUsers{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("expected exactly 1 result from query 'GetAllUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_GetAllUsers) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetAllUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_GetAllUsers) Next() (*Row_UServ_GetAllUsers, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_GetAllUsers{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_GetAllUsers{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_GetAllUsers{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_UServ_GetAllUsers{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_UServ_GetAllUsers{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_UServ_GetAllUsers{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_UServ_GetAllUsers{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp().Empty()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_UServ_GetAllUsers{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_UServ_GetAllUsers{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}

		default:
			return &Row_UServ_GetAllUsers{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_GetAllUsers{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_GetAllUsers) Slice() []*Row_UServ_GetAllUsers {
	var results []*Row_UServ_GetAllUsers
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_GetAllUsers) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_SelectUserById struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_SelectUserById) IterOutTypeUser() {}
func (this *Iter_UServ_SelectUserById) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_SelectUserById) Each(fun func(*Row_UServ_SelectUserById) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_SelectUserById) One() *Row_UServ_SelectUserById {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_SelectUserById{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_SelectUserById{err: fmt.Errorf("expected exactly 1 result from query 'SelectUserById' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_SelectUserById) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SelectUserById'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_SelectUserById) Next() (*Row_UServ_SelectUserById, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_SelectUserById{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_SelectUserById{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_SelectUserById{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_UServ_SelectUserById{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_UServ_SelectUserById{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_UServ_SelectUserById{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_UServ_SelectUserById{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp().Empty()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_UServ_SelectUserById{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_UServ_SelectUserById{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}

		default:
			return &Row_UServ_SelectUserById{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_SelectUserById{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_SelectUserById) Slice() []*Row_UServ_SelectUserById {
	var results []*Row_UServ_SelectUserById
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_SelectUserById) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_UpdateUserName struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_UpdateUserName) IterOutTypeUser() {}
func (this *Iter_UServ_UpdateUserName) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_UpdateUserName) Each(fun func(*Row_UServ_UpdateUserName) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_UpdateUserName) One() *Row_UServ_UpdateUserName {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_UpdateUserName{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("expected exactly 1 result from query 'UpdateUserName' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_UpdateUserName) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateUserName'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_UpdateUserName) Next() (*Row_UServ_UpdateUserName, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_UpdateUserName{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_UpdateUserName{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_UpdateUserName{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_UServ_UpdateUserName{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_UServ_UpdateUserName{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_UServ_UpdateUserName{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_UServ_UpdateUserName{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp().Empty()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_UServ_UpdateUserName{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_UServ_UpdateUserName{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}

		default:
			return &Row_UServ_UpdateUserName{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_UpdateUserName{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_UpdateUserName) Slice() []*Row_UServ_UpdateUserName {
	var results []*Row_UServ_UpdateUserName
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_UpdateUserName) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_UpdateNameToFoo struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_UpdateNameToFoo) IterOutTypeEmpty() {}
func (this *Iter_UServ_UpdateNameToFoo) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_UpdateNameToFoo) Each(fun func(*Row_UServ_UpdateNameToFoo) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_UpdateNameToFoo) One() *Row_UServ_UpdateNameToFoo {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_UpdateNameToFoo{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_UpdateNameToFoo{err: fmt.Errorf("expected exactly 1 result from query 'UpdateNameToFoo' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_UpdateNameToFoo) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateNameToFoo'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_UpdateNameToFoo) Next() (*Row_UServ_UpdateNameToFoo, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_UpdateNameToFoo{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_UpdateNameToFoo{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_UpdateNameToFoo{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_UServ_UpdateNameToFoo{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_UpdateNameToFoo{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_UpdateNameToFoo) Slice() []*Row_UServ_UpdateNameToFoo {
	var results []*Row_UServ_UpdateNameToFoo
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_UpdateNameToFoo) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_GetFriends struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_GetFriends) IterOutTypeUser()      {}
func (this *Iter_UServ_GetFriends) IterInTypeFriendsReq() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_GetFriends) Each(fun func(*Row_UServ_GetFriends) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_GetFriends) One() *Row_UServ_GetFriends {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_GetFriends{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_GetFriends{err: fmt.Errorf("expected exactly 1 result from query 'GetFriends' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_GetFriends) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetFriends'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_GetFriends) Next() (*Row_UServ_GetFriends, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_GetFriends{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_GetFriends{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_GetFriends{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_UServ_GetFriends{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_UServ_GetFriends{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_UServ_GetFriends{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_UServ_GetFriends{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp().Empty()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_UServ_GetFriends{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_UServ_GetFriends{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}

		default:
			return &Row_UServ_GetFriends{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_GetFriends{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_GetFriends) Slice() []*Row_UServ_GetFriends {
	var results []*Row_UServ_GetFriends
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_GetFriends) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_UServ_Drop struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_Drop) IterOutTypeEmpty() {}
func (this *Iter_UServ_Drop) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_Drop) Each(fun func(*Row_UServ_Drop) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_Drop) One() *Row_UServ_Drop {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_Drop{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_Drop{err: fmt.Errorf("expected exactly 1 result from query 'Drop' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_Drop) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Drop'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_Drop) Next() (*Row_UServ_Drop, bool) {
	if this.rows == nil || this.err == io.EOF {
		return nil, false
	} else if this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_UServ_Drop{err: err}, true
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_UServ_Drop{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_UServ_Drop{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_UServ_Drop{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_UServ_Drop{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_Drop) Slice() []*Row_UServ_Drop {
	var results []*Row_UServ_Drop
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_UServ_Drop) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type In_UServ_CreateUsersTable interface {
}
type Out_UServ_CreateUsersTable interface {
}
type Row_UServ_CreateUsersTable struct {
	item Out_UServ_CreateUsersTable
	err  error
}

func newRowUServCreateUsersTable(item Out_UServ_CreateUsersTable, err error) *Row_UServ_CreateUsersTable {
	return &Row_UServ_CreateUsersTable{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_CreateUsersTable) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_CreateUsersTable) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_CreateUsersTable) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_InsertUsers interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_InsertUsers interface {
}
type Row_UServ_InsertUsers struct {
	item Out_UServ_InsertUsers
	err  error
}

func newRowUServInsertUsers(item Out_UServ_InsertUsers, err error) *Row_UServ_InsertUsers {
	return &Row_UServ_InsertUsers{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_InsertUsers) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty2); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty2 before giving to Unwrap()")
		}
		res, _ := this.Empty2()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_InsertUsers) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_UServ_InsertUsers) Empty2() (*Empty2, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty2{}, nil
}

func (this *Row_UServ_InsertUsers) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_GetAllUsers interface {
}
type Out_UServ_GetAllUsers interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_GetAllUsers struct {
	item Out_UServ_GetAllUsers
	err  error
}

func newRowUServGetAllUsers(item Out_UServ_GetAllUsers, err error) *Row_UServ_GetAllUsers {
	return &Row_UServ_GetAllUsers{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_GetAllUsers) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_GetAllUsers) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_GetAllUsers) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_SelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_SelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_SelectUserById struct {
	item Out_UServ_SelectUserById
	err  error
}

func newRowUServSelectUserById(item Out_UServ_SelectUserById, err error) *Row_UServ_SelectUserById {
	return &Row_UServ_SelectUserById{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_SelectUserById) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_SelectUserById) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_SelectUserById) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_UpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_UpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_UpdateUserName struct {
	item Out_UServ_UpdateUserName
	err  error
}

func newRowUServUpdateUserName(item Out_UServ_UpdateUserName, err error) *Row_UServ_UpdateUserName {
	return &Row_UServ_UpdateUserName{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_UpdateUserName) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_UpdateUserName) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_UpdateUserName) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_UpdateNameToFoo interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_UpdateNameToFoo interface {
}
type Row_UServ_UpdateNameToFoo struct {
	item Out_UServ_UpdateNameToFoo
	err  error
}

func newRowUServUpdateNameToFoo(item Out_UServ_UpdateNameToFoo, err error) *Row_UServ_UpdateNameToFoo {
	return &Row_UServ_UpdateNameToFoo{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_UpdateNameToFoo) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_UpdateNameToFoo) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_UpdateNameToFoo) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_GetFriends interface {
	GetNames() *SliceStringParam
}
type Out_UServ_GetFriends interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_GetFriends struct {
	item Out_UServ_GetFriends
	err  error
}

func newRowUServGetFriends(item Out_UServ_GetFriends, err error) *Row_UServ_GetFriends {
	return &Row_UServ_GetFriends{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_GetFriends) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_GetFriends) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_GetFriends) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_Drop interface {
}
type Out_UServ_Drop interface {
}
type Row_UServ_Drop struct {
	item Out_UServ_Drop
	err  error
}

func newRowUServDrop(item Out_UServ_Drop, err error) *Row_UServ_Drop {
	return &Row_UServ_Drop{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_Drop) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_Drop) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_Drop) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type Hooks_UServ interface {
	InsertUsersBeforeHook(context.Context, *User) (*Empty2, error)
	GetAllUsersBeforeHook(context.Context, *Empty) (*User, error)
	InsertUsersAfterHook(context.Context, *User, *Empty2) error
	GetAllUsersAfterHook(context.Context, *Empty, *User) error
}
type DefaultHooks_UServ struct{}

func (*DefaultHooks_UServ) InsertUsersBeforeHook(context.Context, *User) (*Empty2, error) {
	return nil, nil
}
func (*DefaultHooks_UServ) GetAllUsersBeforeHook(context.Context, *Empty) (*User, error) {
	return nil, nil
}
func (*DefaultHooks_UServ) InsertUsersAfterHook(context.Context, *User, *Empty2) error {
	return nil
}
func (*DefaultHooks_UServ) GetAllUsersAfterHook(context.Context, *Empty, *User) error {
	return nil
}

type TypeMappings_UServ interface {
	TimestampTimestamp() MappingImpl_UServ_TimestampTimestamp
	SliceStringParam() MappingImpl_UServ_SliceStringParam
}
type DefaultTypeMappings_UServ struct{}

func (this *DefaultTypeMappings_UServ) TimestampTimestamp() MappingImpl_UServ_TimestampTimestamp {
	return &DefaultMappingImpl_UServ_TimestampTimestamp{}
}

type DefaultMappingImpl_UServ_TimestampTimestamp struct{}

func (this *DefaultMappingImpl_UServ_TimestampTimestamp) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) Empty() MappingImpl_UServ_TimestampTimestamp {
	return this
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) ToSql(*timestamp.Timestamp) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_UServ_TimestampTimestamp interface {
	ToProto(**timestamp.Timestamp) error
	Empty() MappingImpl_UServ_TimestampTimestamp
	ToSql(*timestamp.Timestamp) sql.Scanner
	sql.Scanner
	driver.Valuer
}

func (this *DefaultTypeMappings_UServ) SliceStringParam() MappingImpl_UServ_SliceStringParam {
	return &DefaultMappingImpl_UServ_SliceStringParam{}
}

type DefaultMappingImpl_UServ_SliceStringParam struct{}

func (this *DefaultMappingImpl_UServ_SliceStringParam) ToProto(**SliceStringParam) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) Empty() MappingImpl_UServ_SliceStringParam {
	return this
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) ToSql(*SliceStringParam) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_UServ_SliceStringParam interface {
	ToProto(**SliceStringParam) error
	Empty() MappingImpl_UServ_SliceStringParam
	ToSql(*SliceStringParam) sql.Scanner
	sql.Scanner
	driver.Valuer
}

type Opts_UServ struct {
	MAPPINGS TypeMappings_UServ
	HOOKS    Hooks_UServ
}

func OptsUServ(hooks Hooks_UServ, mappings TypeMappings_UServ) Opts_UServ {
	opts := Opts_UServ{
		HOOKS:    &DefaultHooks_UServ{},
		MAPPINGS: &DefaultTypeMappings_UServ{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_UServ struct {
	opts     *Opts_UServ
	QUERIES  *Queries_UServ
	HANDLERS RestOfHandlers_UServ
	DB       *sql.DB
}

func ImplUServ(db *sql.DB, handlers RestOfHandlers_UServ, opts ...Opts_UServ) *Impl_UServ {
	var myOpts Opts_UServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsUServ(&DefaultHooks_UServ{}, &DefaultTypeMappings_UServ{})
	}
	return &Impl_UServ{
		opts:     &myOpts,
		QUERIES:  QueriesUServ(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_UServ interface {
	UpdateUserNames(UServ_UpdateUserNamesServer) error
	UpdateAllNames(*Empty, UServ_UpdateAllNamesServer) error
}

func (this *Impl_UServ) UpdateUserNames(stream UServ_UpdateUserNamesServer) error {
	return this.HANDLERS.UpdateUserNames(stream)
}

func (this *Impl_UServ) UpdateAllNames(req *Empty, stream UServ_UpdateAllNamesServer) error {
	return this.HANDLERS.UpdateAllNames(req, stream)
}

func (this *Impl_UServ) CreateTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.CreateUsersTable(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) InsertUsers(stream UServ_InsertUsersServer) error {
	tx, err := DefaultClientStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.InsertUsersTx(stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'insert_users' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) InsertUsersTx(stream UServ_InsertUsersServer, tx PersistTx) error {
	query := this.QUERIES.InsertUsers(stream.Context(), tx)
	var first *User
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		beforeRes, err := this.opts.HOOKS.InsertUsersBeforeHook(stream.Context(), req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}

		result := query.Execute(req)
		if err := result.Zero(); err != nil {
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			return fmt.Errorf("error executing 'insert_users' query :::AND COULD NOT ROLLBACK::: rollback err: %v, query err: %v", rollbackErr, err)
		}
	}
	res := &Empty2{}

	if err := this.opts.HOOKS.InsertUsersAfterHook(stream.Context(), first, res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

func (this *Impl_UServ) GetAllUsers(req *Empty, stream UServ_GetAllUsersServer) error {
	tx, err := DefaultServerStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.GetAllUsersTx(req, stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_all_users' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) GetAllUsersTx(req *Empty, stream UServ_GetAllUsersServer, tx PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.GetAllUsers(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_UServ_GetAllUsers) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_UServ) SelectUserById(ctx context.Context, req *User) (*User, error) {
	query := this.QUERIES.SelectUserById(ctx, this.DB)

	result := query.Execute(req)
	res, err := result.One().User()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) UpdateNameToFoo(ctx context.Context, req *User) (*Empty, error) {
	query := this.QUERIES.UpdateNameToFoo(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) GetFriends(req *FriendsReq, stream UServ_GetFriendsServer) error {
	tx, err := DefaultServerStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.GetFriendsTx(req, stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_friends' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) GetFriendsTx(req *FriendsReq, stream UServ_GetFriendsServer, tx PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.GetFriends(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_UServ_GetFriends) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_UServ) DropTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.Drop(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}
