// This file is generated by protoc-gen-persist
// Source File: pb/extra_persist_service_in_pkg.proto
// DO NOT EDIT !
package pb

import (
	sql "database/sql"
	driver "database/sql/driver"
	fmt "fmt"
	io "io"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	imports "github.com/tcncloud/protoc-gen-persistexamples/user_sql/pb/imports"
	persist "github.com/tcncloud/protoc-gen-persist/persist"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

// Queries_ExtraServ holds all the queries found the proto service option as methods
type Queries_ExtraServ struct {
	opts Opts_ExtraServ
}

// QueriesExtraServ returns all the known 'SQL' queires for the 'ExtraServ' service.
// If no opts are provided default implementations are used.
func QueriesExtraServ(opts ...Opts_ExtraServ) *Queries_ExtraServ {
	var myOpts Opts_ExtraServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsExtraServ(&DefaultHooks_ExtraServ{}, &DefaultTypeMappings_ExtraServ{})
	}
	return &Queries_ExtraServ{
		opts: myOpts,
	}
}

// ExtraCreateUsersTable returns a struct that will perform the 'extra_create_users_table' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_ExtraServ) ExtraCreateUsersTable(ctx context.Context, db persist.Runnable) *Query_ExtraServ_ExtraCreateUsersTable {
	return &Query_ExtraServ_ExtraCreateUsersTable{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_ExtraServ_ExtraCreateUsersTable (future doc string needed)
type Query_ExtraServ_ExtraCreateUsersTable struct {
	opts Opts_ExtraServ
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_ExtraServ_ExtraCreateUsersTable) QueryInType_Empty()  {}
func (this *Query_ExtraServ_ExtraCreateUsersTable) QueryOutType_Empty() {}

// Executes the query 'extra_create_users_table' with parameters retrieved from x.
// Fields used: []
func (this *Query_ExtraServ_ExtraCreateUsersTable) Execute(x In_ExtraServ_ExtraCreateUsersTable) *Iter_ExtraServ_ExtraCreateUsersTable {
	var setupErr error
	params := []interface{}{}
	result := &Iter_ExtraServ_ExtraCreateUsersTable{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "CREATE TABLE users(id integer PRIMARY KEY, name VARCHAR(50), friends BYTEA, created_on VARCHAR(50), id2 SMALLINT, counts []BIGINT)", params...)
	return result
}

// ExtraGetAllUsers returns a struct that will perform the 'extra_get_all_users' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_ExtraServ) ExtraGetAllUsers(ctx context.Context, db persist.Runnable) *Query_ExtraServ_ExtraGetAllUsers {
	return &Query_ExtraServ_ExtraGetAllUsers{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_ExtraServ_ExtraGetAllUsers (future doc string needed)
type Query_ExtraServ_ExtraGetAllUsers struct {
	opts Opts_ExtraServ
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_ExtraServ_ExtraGetAllUsers) QueryInType_Empty() {}
func (this *Query_ExtraServ_ExtraGetAllUsers) QueryOutType_User() {}

// Executes the query 'extra_get_all_users' with parameters retrieved from x.
// Fields used: []
func (this *Query_ExtraServ_ExtraGetAllUsers) Execute(x In_ExtraServ_ExtraGetAllUsers) *Iter_ExtraServ_ExtraGetAllUsers {
	var setupErr error
	params := []interface{}{}
	result := &Iter_ExtraServ_ExtraGetAllUsers{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id, name, friends, created_on, id2 FROM users", params...)
	return result
}

// ExtraSelectUserById returns a struct that will perform the 'extra_select_user_by_id' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_ExtraServ) ExtraSelectUserById(ctx context.Context, db persist.Runnable) *Query_ExtraServ_ExtraSelectUserById {
	return &Query_ExtraServ_ExtraSelectUserById{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_ExtraServ_ExtraSelectUserById (future doc string needed)
type Query_ExtraServ_ExtraSelectUserById struct {
	opts Opts_ExtraServ
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_ExtraServ_ExtraSelectUserById) QueryInType_User()  {}
func (this *Query_ExtraServ_ExtraSelectUserById) QueryOutType_User() {}

// Executes the query 'extra_select_user_by_id' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_ExtraServ_ExtraSelectUserById) Execute(x In_ExtraServ_ExtraSelectUserById) *Iter_ExtraServ_ExtraSelectUserById {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_ExtraServ_ExtraSelectUserById{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id, name, friends, created_on, id2 FROM users WHERE id = $1", params...)
	return result
}

// ExtraUpdateUserName returns a struct that will perform the 'extra_update_user_name' query.
// When Execute is called, it will use the following fields:
// [name id]
func (this *Queries_ExtraServ) ExtraUpdateUserName(ctx context.Context, db persist.Runnable) *Query_ExtraServ_ExtraUpdateUserName {
	return &Query_ExtraServ_ExtraUpdateUserName{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_ExtraServ_ExtraUpdateUserName (future doc string needed)
type Query_ExtraServ_ExtraUpdateUserName struct {
	opts Opts_ExtraServ
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_ExtraServ_ExtraUpdateUserName) QueryInType_User()  {}
func (this *Query_ExtraServ_ExtraUpdateUserName) QueryOutType_User() {}

// Executes the query 'extra_update_user_name' with parameters retrieved from x.
// Fields used: [name id]
func (this *Query_ExtraServ_ExtraUpdateUserName) Execute(x In_ExtraServ_ExtraUpdateUserName) *Iter_ExtraServ_ExtraUpdateUserName {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetName()
			return
		}(),
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_ExtraServ_ExtraUpdateUserName{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "Update users set name = $1 WHERE id = $2  RETURNING id, name, friends, created_on", params...)
	return result
}

type Iter_ExtraServ_ExtraCreateUsersTable struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_ExtraServ
	ctx    context.Context
}

func (this *Iter_ExtraServ_ExtraCreateUsersTable) IterOutTypeEmpty() {}
func (this *Iter_ExtraServ_ExtraCreateUsersTable) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_ExtraServ_ExtraCreateUsersTable) Each(fun func(*Row_ExtraServ_ExtraCreateUsersTable) error) error {
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_ExtraServ_ExtraCreateUsersTable) One() *Row_ExtraServ_ExtraCreateUsersTable {
	first, hasFirst := this.Next()
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_ExtraServ_ExtraCreateUsersTable{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_ExtraServ_ExtraCreateUsersTable{err: persist.NotFound{Msg: fmt.Sprintf("expected exactly 1 result from query 'ExtraCreateUsersTable' found %s", amount)}}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_ExtraServ_ExtraCreateUsersTable) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ExtraCreateUsersTable'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_ExtraServ_ExtraCreateUsersTable) Next() (*Row_ExtraServ_ExtraCreateUsersTable, bool) {
	if this.err == io.EOF {
		return nil, false
	}
	if this.err != nil {
		err := this.err
		this.err = io.EOF
		if this.rows != nil {
			this.rows.Close()
		}
		return &Row_ExtraServ_ExtraCreateUsersTable{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_ExtraServ_ExtraCreateUsersTable{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_ExtraServ_ExtraCreateUsersTable{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_ExtraServ_ExtraCreateUsersTable{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_ExtraServ_ExtraCreateUsersTable{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_ExtraServ_ExtraCreateUsersTable{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_ExtraServ_ExtraCreateUsersTable) Slice() []*Row_ExtraServ_ExtraCreateUsersTable {
	var results []*Row_ExtraServ_ExtraCreateUsersTable
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_ExtraServ_ExtraCreateUsersTable) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_ExtraServ_ExtraGetAllUsers struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_ExtraServ
	ctx    context.Context
}

func (this *Iter_ExtraServ_ExtraGetAllUsers) IterOutTypeUser() {}
func (this *Iter_ExtraServ_ExtraGetAllUsers) IterInTypeEmpty() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_ExtraServ_ExtraGetAllUsers) Each(fun func(*Row_ExtraServ_ExtraGetAllUsers) error) error {
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_ExtraServ_ExtraGetAllUsers) One() *Row_ExtraServ_ExtraGetAllUsers {
	first, hasFirst := this.Next()
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_ExtraServ_ExtraGetAllUsers{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_ExtraServ_ExtraGetAllUsers{err: persist.NotFound{Msg: fmt.Sprintf("expected exactly 1 result from query 'ExtraGetAllUsers' found %s", amount)}}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_ExtraServ_ExtraGetAllUsers) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ExtraGetAllUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_ExtraServ_ExtraGetAllUsers) Next() (*Row_ExtraServ_ExtraGetAllUsers, bool) {
	if this.err == io.EOF {
		return nil, false
	}
	if this.err != nil {
		err := this.err
		this.err = io.EOF
		if this.rows != nil {
			this.rows.Close()
		}
		return &Row_ExtraServ_ExtraGetAllUsers{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_ExtraServ_ExtraGetAllUsers{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_ExtraServ_ExtraGetAllUsers{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_ExtraServ_ExtraGetAllUsers{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = int64(r)
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_ExtraServ_ExtraGetAllUsers{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}
		case "id2":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("cant convert db column id2 to protobuf go type ")}, true
			}
			res.Id2 = int32(r)
		case "counts":
			var converted = this.tm.Int64Slice()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("could not convert mapped db column counts to type on User.Counts: %v", err)}, true
			}
			if err := converted.ToProto(&res.Counts); err != nil {
				return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("could not convert mapped db column countsto type on User.Counts: %v", err)}, true
			}

		default:
			return &Row_ExtraServ_ExtraGetAllUsers{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_ExtraServ_ExtraGetAllUsers{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_ExtraServ_ExtraGetAllUsers) Slice() []*Row_ExtraServ_ExtraGetAllUsers {
	var results []*Row_ExtraServ_ExtraGetAllUsers
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_ExtraServ_ExtraGetAllUsers) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_ExtraServ_ExtraSelectUserById struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_ExtraServ
	ctx    context.Context
}

func (this *Iter_ExtraServ_ExtraSelectUserById) IterOutTypeUser() {}
func (this *Iter_ExtraServ_ExtraSelectUserById) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_ExtraServ_ExtraSelectUserById) Each(fun func(*Row_ExtraServ_ExtraSelectUserById) error) error {
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_ExtraServ_ExtraSelectUserById) One() *Row_ExtraServ_ExtraSelectUserById {
	first, hasFirst := this.Next()
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_ExtraServ_ExtraSelectUserById{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_ExtraServ_ExtraSelectUserById{err: persist.NotFound{Msg: fmt.Sprintf("expected exactly 1 result from query 'ExtraSelectUserById' found %s", amount)}}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_ExtraServ_ExtraSelectUserById) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ExtraSelectUserById'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_ExtraServ_ExtraSelectUserById) Next() (*Row_ExtraServ_ExtraSelectUserById, bool) {
	if this.err == io.EOF {
		return nil, false
	}
	if this.err != nil {
		err := this.err
		this.err = io.EOF
		if this.rows != nil {
			this.rows.Close()
		}
		return &Row_ExtraServ_ExtraSelectUserById{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_ExtraServ_ExtraSelectUserById{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_ExtraServ_ExtraSelectUserById{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_ExtraServ_ExtraSelectUserById{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = int64(r)
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_ExtraServ_ExtraSelectUserById{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}
		case "id2":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("cant convert db column id2 to protobuf go type ")}, true
			}
			res.Id2 = int32(r)
		case "counts":
			var converted = this.tm.Int64Slice()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("could not convert mapped db column counts to type on User.Counts: %v", err)}, true
			}
			if err := converted.ToProto(&res.Counts); err != nil {
				return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("could not convert mapped db column countsto type on User.Counts: %v", err)}, true
			}

		default:
			return &Row_ExtraServ_ExtraSelectUserById{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_ExtraServ_ExtraSelectUserById{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_ExtraServ_ExtraSelectUserById) Slice() []*Row_ExtraServ_ExtraSelectUserById {
	var results []*Row_ExtraServ_ExtraSelectUserById
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_ExtraServ_ExtraSelectUserById) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_ExtraServ_ExtraUpdateUserName struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_ExtraServ
	ctx    context.Context
}

func (this *Iter_ExtraServ_ExtraUpdateUserName) IterOutTypeUser() {}
func (this *Iter_ExtraServ_ExtraUpdateUserName) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_ExtraServ_ExtraUpdateUserName) Each(fun func(*Row_ExtraServ_ExtraUpdateUserName) error) error {
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_ExtraServ_ExtraUpdateUserName) One() *Row_ExtraServ_ExtraUpdateUserName {
	first, hasFirst := this.Next()
	defer func() {
		if this.rows != nil {
			this.rows.Close()
		}
	}()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_ExtraServ_ExtraUpdateUserName{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_ExtraServ_ExtraUpdateUserName{err: persist.NotFound{Msg: fmt.Sprintf("expected exactly 1 result from query 'ExtraUpdateUserName' found %s", amount)}}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_ExtraServ_ExtraUpdateUserName) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ExtraUpdateUserName'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_ExtraServ_ExtraUpdateUserName) Next() (*Row_ExtraServ_ExtraUpdateUserName, bool) {
	if this.err == io.EOF {
		return nil, false
	}
	if this.err != nil {
		err := this.err
		this.err = io.EOF
		if this.rows != nil {
			this.rows.Close()
		}
		return &Row_ExtraServ_ExtraUpdateUserName{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_ExtraServ_ExtraUpdateUserName{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_ExtraServ_ExtraUpdateUserName{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_ExtraServ_ExtraUpdateUserName{err: this.err}, true
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("cant convert db column id to protobuf go type ")}, true
			}
			res.Id = int64(r)
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("cant convert db column name to protobuf go type ")}, true
			}
			res.Name = r
		case "friends":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("cant convert db column friends to protobuf go type *Friends")}, true
			}
			var converted = new(Friends)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_ExtraServ_ExtraUpdateUserName{err: err}, true
			}
			res.Friends = converted
		case "created_on":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)}, true
			}
			if err := converted.ToProto(&res.CreatedOn); err != nil {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("could not convert mapped db column created_onto type on User.CreatedOn: %v", err)}, true
			}
		case "id2":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("cant convert db column id2 to protobuf go type ")}, true
			}
			res.Id2 = int32(r)
		case "counts":
			var converted = this.tm.Int64Slice()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("could not convert mapped db column counts to type on User.Counts: %v", err)}, true
			}
			if err := converted.ToProto(&res.Counts); err != nil {
				return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("could not convert mapped db column countsto type on User.Counts: %v", err)}, true
			}

		default:
			return &Row_ExtraServ_ExtraUpdateUserName{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_ExtraServ_ExtraUpdateUserName{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_ExtraServ_ExtraUpdateUserName) Slice() []*Row_ExtraServ_ExtraUpdateUserName {
	var results []*Row_ExtraServ_ExtraUpdateUserName
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_ExtraServ_ExtraUpdateUserName) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type In_ExtraServ_ExtraCreateUsersTable interface {
}
type Out_ExtraServ_ExtraCreateUsersTable interface {
}
type Row_ExtraServ_ExtraCreateUsersTable struct {
	item Out_ExtraServ_ExtraCreateUsersTable
	err  error
}

func newRowExtraServExtraCreateUsersTable(item Out_ExtraServ_ExtraCreateUsersTable, err error) *Row_ExtraServ_ExtraCreateUsersTable {
	return &Row_ExtraServ_ExtraCreateUsersTable{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_ExtraServ_ExtraCreateUsersTable) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_ExtraServ_ExtraCreateUsersTable) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_ExtraServ_ExtraCreateUsersTable) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_ExtraServ_ExtraGetAllUsers interface {
}
type Out_ExtraServ_ExtraGetAllUsers interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
	GetId2() int32
	GetCounts() []int64
}
type Row_ExtraServ_ExtraGetAllUsers struct {
	item Out_ExtraServ_ExtraGetAllUsers
	err  error
}

func newRowExtraServExtraGetAllUsers(item Out_ExtraServ_ExtraGetAllUsers, err error) *Row_ExtraServ_ExtraGetAllUsers {
	return &Row_ExtraServ_ExtraGetAllUsers{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_ExtraServ_ExtraGetAllUsers) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		o.Id2 = res.Id2
		o.Counts = res.Counts
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		o.Id2 = res.Id2
		o.Counts = res.Counts
		return nil
	}

	return nil
}
func (this *Row_ExtraServ_ExtraGetAllUsers) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

func (this *Row_ExtraServ_ExtraGetAllUsers) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

type In_ExtraServ_ExtraSelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
	GetId2() int32
	GetCounts() []int64
}
type Out_ExtraServ_ExtraSelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
	GetId2() int32
	GetCounts() []int64
}
type Row_ExtraServ_ExtraSelectUserById struct {
	item Out_ExtraServ_ExtraSelectUserById
	err  error
}

func newRowExtraServExtraSelectUserById(item Out_ExtraServ_ExtraSelectUserById, err error) *Row_ExtraServ_ExtraSelectUserById {
	return &Row_ExtraServ_ExtraSelectUserById{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_ExtraServ_ExtraSelectUserById) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		o.Id2 = res.Id2
		o.Counts = res.Counts
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		o.Id2 = res.Id2
		o.Counts = res.Counts
		return nil
	}

	return nil
}
func (this *Row_ExtraServ_ExtraSelectUserById) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

func (this *Row_ExtraServ_ExtraSelectUserById) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

type In_ExtraServ_ExtraUpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
	GetId2() int32
	GetCounts() []int64
}
type Out_ExtraServ_ExtraUpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
	GetId2() int32
	GetCounts() []int64
}
type Row_ExtraServ_ExtraUpdateUserName struct {
	item Out_ExtraServ_ExtraUpdateUserName
	err  error
}

func newRowExtraServExtraUpdateUserName(item Out_ExtraServ_ExtraUpdateUserName, err error) *Row_ExtraServ_ExtraUpdateUserName {
	return &Row_ExtraServ_ExtraUpdateUserName{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_ExtraServ_ExtraUpdateUserName) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		o.Id2 = res.Id2
		o.Counts = res.Counts
		return nil
	}

	return nil
}
func (this *Row_ExtraServ_ExtraUpdateUserName) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

func (this *Row_ExtraServ_ExtraUpdateUserName) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
		Id2:       this.item.GetId2(),
		Counts:    this.item.GetCounts(),
	}, nil
}

type Hooks_ExtraServ interface {
	GetAllUsersBeforeHook(context.Context, *Empty) (*User, error)
	GetAllUsersAfterHook(context.Context, *Empty, *User) error
}
type DefaultHooks_ExtraServ struct{}

func (*DefaultHooks_ExtraServ) GetAllUsersBeforeHook(context.Context, *Empty) (*User, error) {
	return nil, nil
}
func (*DefaultHooks_ExtraServ) GetAllUsersAfterHook(context.Context, *Empty, *User) error {
	return nil
}

type TypeMappings_ExtraServ interface {
	TimestampTimestamp() MappingImpl_ExtraServ_TimestampTimestamp
	SliceStringParam() MappingImpl_ExtraServ_SliceStringParam
	Int64Slice() MappingImpl_ExtraServ_Int64Slice
}
type DefaultTypeMappings_ExtraServ struct{}

func (this *DefaultTypeMappings_ExtraServ) TimestampTimestamp() MappingImpl_ExtraServ_TimestampTimestamp {
	return &DefaultMappingImpl_ExtraServ_TimestampTimestamp{}
}

type DefaultMappingImpl_ExtraServ_TimestampTimestamp struct{}

func (this *DefaultMappingImpl_ExtraServ_TimestampTimestamp) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_TimestampTimestamp) ToSql(*timestamp.Timestamp) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_ExtraServ_TimestampTimestamp) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_TimestampTimestamp) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_ExtraServ_TimestampTimestamp interface {
	ToProto(**timestamp.Timestamp) error
	ToSql(*timestamp.Timestamp) sql.Scanner
	sql.Scanner
	driver.Valuer
}

func (this *DefaultTypeMappings_ExtraServ) SliceStringParam() MappingImpl_ExtraServ_SliceStringParam {
	return &DefaultMappingImpl_ExtraServ_SliceStringParam{}
}

type DefaultMappingImpl_ExtraServ_SliceStringParam struct{}

func (this *DefaultMappingImpl_ExtraServ_SliceStringParam) ToProto(**SliceStringParam) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_SliceStringParam) ToSql(*SliceStringParam) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_ExtraServ_SliceStringParam) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_SliceStringParam) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_ExtraServ_SliceStringParam interface {
	ToProto(**SliceStringParam) error
	ToSql(*SliceStringParam) sql.Scanner
	sql.Scanner
	driver.Valuer
}

func (this *DefaultTypeMappings_ExtraServ) Int64Slice() MappingImpl_ExtraServ_Int64Slice {
	return &DefaultMappingImpl_ExtraServ_Int64Slice{}
}

type DefaultMappingImpl_ExtraServ_Int64Slice struct{}

func (this *DefaultMappingImpl_ExtraServ_Int64Slice) ToProto(*[]int64) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_Int64Slice) ToSql([]int64) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_ExtraServ_Int64Slice) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_ExtraServ_Int64Slice) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_ExtraServ_Int64Slice interface {
	ToProto(*[]int64) error
	ToSql([]int64) sql.Scanner
	sql.Scanner
	driver.Valuer
}

type Opts_ExtraServ struct {
	MAPPINGS TypeMappings_ExtraServ
	HOOKS    Hooks_ExtraServ
}

func OptsExtraServ(hooks Hooks_ExtraServ, mappings TypeMappings_ExtraServ) Opts_ExtraServ {
	opts := Opts_ExtraServ{
		HOOKS:    &DefaultHooks_ExtraServ{},
		MAPPINGS: &DefaultTypeMappings_ExtraServ{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_ExtraServ struct {
	opts     *Opts_ExtraServ
	QUERIES  *Queries_ExtraServ
	HANDLERS RestOfHandlers_ExtraServ
	DB       *sql.DB
}

func ImplExtraServ(db *sql.DB, handlers RestOfHandlers_ExtraServ, opts ...Opts_ExtraServ) *Impl_ExtraServ {
	var myOpts Opts_ExtraServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsExtraServ(&DefaultHooks_ExtraServ{}, &DefaultTypeMappings_ExtraServ{})
	}
	return &Impl_ExtraServ{
		opts:     &myOpts,
		QUERIES:  QueriesExtraServ(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_ExtraServ interface {
	EEEE(context.Context, *timestamp.Timestamp) (*Empty, error)
	UpdateAllNames(*Empty, ExtraServ_UpdateAllNamesServer) error
}

func (this *Impl_ExtraServ) EEEE(ctx context.Context, req *timestamp.Timestamp) (*Empty, error) {
	return this.HANDLERS.EEEE(ctx, req)
}

func (this *Impl_ExtraServ) UpdateAllNames(req *Empty, stream ExtraServ_UpdateAllNamesServer) error {
	return this.HANDLERS.UpdateAllNames(req, stream)
}

func (this *Impl_ExtraServ) CreateTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.ExtraCreateUsersTable(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_ExtraServ) TTTT(ctx context.Context, req *timestamp.Timestamp) (*Empty, error) {
	query := this.QUERIES.ExtraCreateUsersTable(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_ExtraServ) IIII(ctx context.Context, req *imports.Imported) (*Empty, error) {
	query := this.QUERIES.ExtraCreateUsersTable(ctx, this.DB)

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_ExtraServ) GetAllUsers(req *Empty, stream ExtraServ_GetAllUsersServer) error {
	tx, err := DefaultServerStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.GetAllUsersTx(req, stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'extra_get_all_users' query: %v", err)
	}
	return nil
}
func (this *Impl_ExtraServ) GetAllUsersTx(req *Empty, stream ExtraServ_GetAllUsersServer, tx persist.PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.ExtraGetAllUsers(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_ExtraServ_ExtraGetAllUsers) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_ExtraServ) SelectUserById(ctx context.Context, req *User) (*User, error) {
	query := this.QUERIES.ExtraSelectUserById(ctx, this.DB)

	result := query.Execute(req)
	res, err := result.One().User()
	if err != nil {
		return nil, err
	}

	return res, nil
}
