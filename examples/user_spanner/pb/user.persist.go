// This file is generated by protoc-gen-persist
// Source File: pb/user.proto
// DO NOT EDIT !
package pb

import (
	fmt "fmt"
	io "io"

	spanner "cloud.google.com/go/spanner"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	persist "github.com/tcncloud/protoc-gen-persist/persist"
	context "golang.org/x/net/context"
	iterator "google.golang.org/api/iterator"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type Result interface {
	LastInsertId() (int64, error)
	RowsAffected() (int64, error)
}
type SpannerResult struct {
	// TODO shouldn't be an iter
	iter *spanner.RowIterator
}

func (sr *SpannerResult) LastInsertId() (int64, error) {
	// sr.iter.QueryStats or sr.iter.QueryPlan
	return -1, nil
}
func (sr *SpannerResult) RowsAffected() (int64, error) {
	// Execution statistics for the query. Available after RowIterator.Next returns iterator.Done
	return sr.iter.RowCount, nil
}

// Queries_UServ holds all the queries found the proto service option as methods
type Queries_UServ struct {
	opts Opts_UServ
}

// QueriesUServ returns all the known 'SQL' queires for the 'UServ' service.
// If no opts are provided default implementations are used.
func QueriesUServ(opts ...Opts_UServ) *Queries_UServ {
	var myOpts Opts_UServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsUServ(&DefaultHooks_UServ{}, &DefaultTypeMappings_UServ{})
	}
	return &Queries_UServ{
		opts: myOpts,
	}
}

// CreateUsersTable returns a struct that will perform the 'create_users_table' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_UServ) CreateUsersTable(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_CreateUsersTable {
	return &Query_UServ_CreateUsersTable{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_CreateUsersTable (future doc string needed)
type Query_UServ_CreateUsersTable struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_CreateUsersTable) QueryInType_Empty()  {}
func (this *Query_UServ_CreateUsersTable) QueryOutType_Empty() {}

// Executes the query 'create_users_table' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_CreateUsersTable) Execute(x In_UServ_CreateUsersTable) *Iter_UServ_CreateUsersTable {
	ctx := this.ctx
	result := &Iter_UServ_CreateUsersTable{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "CREATE TABLE users(id integer PRIMARY KEY, name VARCHAR(50), friends BYTEA, created_on VARCHAR(50))",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// InsertUsers returns a struct that will perform the 'insert_users' query.
// When Execute is called, it will use the following fields:
// [id name friends created_on]
func (this *Queries_UServ) InsertUsers(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_InsertUsers {
	return &Query_UServ_InsertUsers{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_InsertUsers (future doc string needed)
type Query_UServ_InsertUsers struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_InsertUsers) QueryInType_User()   {}
func (this *Query_UServ_InsertUsers) QueryOutType_Empty() {}

// Executes the query 'insert_users' with parameters retrieved from x.
// Fields used: [id name friends created_on]
func (this *Query_UServ_InsertUsers) Execute(x In_UServ_InsertUsers) *Iter_UServ_InsertUsers {
	ctx := this.ctx
	result := &Iter_UServ_InsertUsers{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		result["name"] = x.GetName()
		friends, err := proto.Marshal(x.GetFriends())
		if err != nil {
			return nil, err
		}
		result["friends"] = friends
		created_on, err := this.opts.MAPPINGS.TimestampTimestamp().ToSpanner(x.GetCreatedOn()).SpannerValue()
		if err != nil {
			return nil, err
		}
		result["created_on"] = created_on

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "INSERT INTO users (id, name, friends, created_on) VALUES (@id, @name, @friends, @created_on)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// GetAllUsers returns a struct that will perform the 'get_all_users' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_UServ) GetAllUsers(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_GetAllUsers {
	return &Query_UServ_GetAllUsers{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_GetAllUsers (future doc string needed)
type Query_UServ_GetAllUsers struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_GetAllUsers) QueryInType_Empty() {}
func (this *Query_UServ_GetAllUsers) QueryOutType_User() {}

// Executes the query 'get_all_users' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_GetAllUsers) Execute(x In_UServ_GetAllUsers) *Iter_UServ_GetAllUsers {
	ctx := this.ctx
	result := &Iter_UServ_GetAllUsers{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on FROM users",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// SelectUserById returns a struct that will perform the 'select_user_by_id' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_UServ) SelectUserById(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_SelectUserById {
	return &Query_UServ_SelectUserById{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_SelectUserById (future doc string needed)
type Query_UServ_SelectUserById struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_SelectUserById) QueryInType_User()  {}
func (this *Query_UServ_SelectUserById) QueryOutType_User() {}

// Executes the query 'select_user_by_id' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_UServ_SelectUserById) Execute(x In_UServ_SelectUserById) *Iter_UServ_SelectUserById {
	ctx := this.ctx
	result := &Iter_UServ_SelectUserById{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on FROM users WHERE id = @id",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// UpdateUserName returns a struct that will perform the 'update_user_name' query.
// When Execute is called, it will use the following fields:
// [name id]
func (this *Queries_UServ) UpdateUserName(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_UpdateUserName {
	return &Query_UServ_UpdateUserName{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_UpdateUserName (future doc string needed)
type Query_UServ_UpdateUserName struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_UpdateUserName) QueryInType_User()  {}
func (this *Query_UServ_UpdateUserName) QueryOutType_User() {}

// Executes the query 'update_user_name' with parameters retrieved from x.
// Fields used: [name id]
func (this *Query_UServ_UpdateUserName) Execute(x In_UServ_UpdateUserName) *Iter_UServ_UpdateUserName {
	ctx := this.ctx
	result := &Iter_UServ_UpdateUserName{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["name"] = x.GetName()
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "UPDATE users SET name = @name WHERE id = @id ",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// UpdateNameToFoo returns a struct that will perform the 'update_name_to_foo' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_UServ) UpdateNameToFoo(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_UpdateNameToFoo {
	return &Query_UServ_UpdateNameToFoo{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_UpdateNameToFoo (future doc string needed)
type Query_UServ_UpdateNameToFoo struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_UpdateNameToFoo) QueryInType_User()   {}
func (this *Query_UServ_UpdateNameToFoo) QueryOutType_Empty() {}

// Executes the query 'update_name_to_foo' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_UServ_UpdateNameToFoo) Execute(x In_UServ_UpdateNameToFoo) *Iter_UServ_UpdateNameToFoo {
	ctx := this.ctx
	result := &Iter_UServ_UpdateNameToFoo{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "UPDATE users SET name = 'foo' WHERE id = @id",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// GetFriends returns a struct that will perform the 'get_friends' query.
// When Execute is called, it will use the following fields:
// [names]
func (this *Queries_UServ) GetFriends(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_GetFriends {
	return &Query_UServ_GetFriends{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_GetFriends (future doc string needed)
type Query_UServ_GetFriends struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_GetFriends) QueryInType_FriendsReq() {}
func (this *Query_UServ_GetFriends) QueryOutType_User()      {}

// Executes the query 'get_friends' with parameters retrieved from x.
// Fields used: [names]
func (this *Query_UServ_GetFriends) Execute(x In_UServ_GetFriends) *Iter_UServ_GetFriends {
	ctx := this.ctx
	result := &Iter_UServ_GetFriends{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		names, err := this.opts.MAPPINGS.SliceStringParam().ToSpanner(x.GetNames()).SpannerValue()
		if err != nil {
			return nil, err
		}
		result["names"] = names

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on  FROM users WHERE name IN UNNEST(@names)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// Drop returns a struct that will perform the 'drop' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_UServ) Drop(ctx context.Context, db persist.SpannerRunnable) *Query_UServ_Drop {
	return &Query_UServ_Drop{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_UServ_Drop (future doc string needed)
type Query_UServ_Drop struct {
	opts Opts_UServ
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_UServ_Drop) QueryInType_Empty()  {}
func (this *Query_UServ_Drop) QueryOutType_Empty() {}

// Executes the query 'drop' with parameters retrieved from x.
// Fields used: []
func (this *Query_UServ_Drop) Execute(x In_UServ_Drop) *Iter_UServ_Drop {
	ctx := this.ctx
	result := &Iter_UServ_Drop{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "drop table users",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

type Iter_UServ_CreateUsersTable struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_CreateUsersTable) IterOutTypeEmpty() {}
func (this *Iter_UServ_CreateUsersTable) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_CreateUsersTable) Each(fun func(*Row_UServ_CreateUsersTable) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_CreateUsersTable) One() *Row_UServ_CreateUsersTable {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_CreateUsersTable{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_CreateUsersTable{err: fmt.Errorf("expected exactly 1 result from query 'CreateUsersTable' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_CreateUsersTable) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'CreateUsersTable'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_CreateUsersTable) Next() (*Row_UServ_CreateUsersTable, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_CreateUsersTable{err: err}, true
	}
	res := &Empty{}
	return &Row_UServ_CreateUsersTable{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_CreateUsersTable) Slice() []*Row_UServ_CreateUsersTable {
	var results []*Row_UServ_CreateUsersTable
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_InsertUsers struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_InsertUsers) IterOutTypeEmpty() {}
func (this *Iter_UServ_InsertUsers) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_InsertUsers) Each(fun func(*Row_UServ_InsertUsers) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_InsertUsers) One() *Row_UServ_InsertUsers {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_InsertUsers{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_InsertUsers{err: fmt.Errorf("expected exactly 1 result from query 'InsertUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_InsertUsers) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'InsertUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_InsertUsers) Next() (*Row_UServ_InsertUsers, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_InsertUsers{err: err}, true
	}
	res := &Empty{}
	return &Row_UServ_InsertUsers{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_InsertUsers) Slice() []*Row_UServ_InsertUsers {
	var results []*Row_UServ_InsertUsers
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_GetAllUsers struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_GetAllUsers) IterOutTypeUser() {}
func (this *Iter_UServ_GetAllUsers) IterInTypeEmpty() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_GetAllUsers) Each(fun func(*Row_UServ_GetAllUsers) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_GetAllUsers) One() *Row_UServ_GetAllUsers {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_GetAllUsers{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("expected exactly 1 result from query 'GetAllUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_GetAllUsers) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetAllUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_GetAllUsers) Next() (*Row_UServ_GetAllUsers, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_GetAllUsers{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &Row_UServ_GetAllUsers{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &Row_UServ_GetAllUsers{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_GetAllUsers) Slice() []*Row_UServ_GetAllUsers {
	var results []*Row_UServ_GetAllUsers
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_SelectUserById struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_SelectUserById) IterOutTypeUser() {}
func (this *Iter_UServ_SelectUserById) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_SelectUserById) Each(fun func(*Row_UServ_SelectUserById) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_SelectUserById) One() *Row_UServ_SelectUserById {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_SelectUserById{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_SelectUserById{err: fmt.Errorf("expected exactly 1 result from query 'SelectUserById' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_SelectUserById) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SelectUserById'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_SelectUserById) Next() (*Row_UServ_SelectUserById, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_SelectUserById{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &Row_UServ_SelectUserById{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &Row_UServ_SelectUserById{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_SelectUserById) Slice() []*Row_UServ_SelectUserById {
	var results []*Row_UServ_SelectUserById
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_UpdateUserName struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_UpdateUserName) IterOutTypeUser() {}
func (this *Iter_UServ_UpdateUserName) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_UpdateUserName) Each(fun func(*Row_UServ_UpdateUserName) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_UpdateUserName) One() *Row_UServ_UpdateUserName {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_UpdateUserName{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("expected exactly 1 result from query 'UpdateUserName' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_UpdateUserName) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateUserName'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_UpdateUserName) Next() (*Row_UServ_UpdateUserName, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_UpdateUserName{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &Row_UServ_UpdateUserName{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &Row_UServ_UpdateUserName{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_UpdateUserName) Slice() []*Row_UServ_UpdateUserName {
	var results []*Row_UServ_UpdateUserName
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_UpdateNameToFoo struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_UpdateNameToFoo) IterOutTypeEmpty() {}
func (this *Iter_UServ_UpdateNameToFoo) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_UpdateNameToFoo) Each(fun func(*Row_UServ_UpdateNameToFoo) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_UpdateNameToFoo) One() *Row_UServ_UpdateNameToFoo {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_UpdateNameToFoo{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_UpdateNameToFoo{err: fmt.Errorf("expected exactly 1 result from query 'UpdateNameToFoo' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_UpdateNameToFoo) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateNameToFoo'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_UpdateNameToFoo) Next() (*Row_UServ_UpdateNameToFoo, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_UpdateNameToFoo{err: err}, true
	}
	res := &Empty{}
	return &Row_UServ_UpdateNameToFoo{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_UpdateNameToFoo) Slice() []*Row_UServ_UpdateNameToFoo {
	var results []*Row_UServ_UpdateNameToFoo
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_GetFriends struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_GetFriends) IterOutTypeUser()      {}
func (this *Iter_UServ_GetFriends) IterInTypeFriendsReq() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_GetFriends) Each(fun func(*Row_UServ_GetFriends) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_GetFriends) One() *Row_UServ_GetFriends {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_GetFriends{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_GetFriends{err: fmt.Errorf("expected exactly 1 result from query 'GetFriends' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_GetFriends) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetFriends'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_GetFriends) Next() (*Row_UServ_GetFriends, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_GetFriends{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &Row_UServ_GetFriends{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &Row_UServ_GetFriends{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_GetFriends) Slice() []*Row_UServ_GetFriends {
	var results []*Row_UServ_GetFriends
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_UServ_Drop struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_UServ
	ctx    context.Context
}

func (this *Iter_UServ_Drop) IterOutTypeEmpty() {}
func (this *Iter_UServ_Drop) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_UServ_Drop) Each(fun func(*Row_UServ_Drop) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_UServ_Drop) One() *Row_UServ_Drop {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_UServ_Drop{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_UServ_Drop{err: fmt.Errorf("expected exactly 1 result from query 'Drop' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_UServ_Drop) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Drop'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_UServ_Drop) Next() (*Row_UServ_Drop, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_UServ_Drop{err: err}, true
	}
	res := &Empty{}
	return &Row_UServ_Drop{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_UServ_Drop) Slice() []*Row_UServ_Drop {
	var results []*Row_UServ_Drop
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type In_UServ_CreateUsersTable interface {
}
type Out_UServ_CreateUsersTable interface {
}
type Row_UServ_CreateUsersTable struct {
	item Out_UServ_CreateUsersTable
	err  error
}

func newRowUServCreateUsersTable(item Out_UServ_CreateUsersTable, err error) *Row_UServ_CreateUsersTable {
	return &Row_UServ_CreateUsersTable{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_CreateUsersTable) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_CreateUsersTable) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_CreateUsersTable) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_InsertUsers interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_InsertUsers interface {
}
type Row_UServ_InsertUsers struct {
	item Out_UServ_InsertUsers
	err  error
}

func newRowUServInsertUsers(item Out_UServ_InsertUsers, err error) *Row_UServ_InsertUsers {
	return &Row_UServ_InsertUsers{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_InsertUsers) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty2); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty2 before giving to Unwrap()")
		}
		res, _ := this.Empty2()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_InsertUsers) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_UServ_InsertUsers) Empty2() (*Empty2, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty2{}, nil
}

func (this *Row_UServ_InsertUsers) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_GetAllUsers interface {
}
type Out_UServ_GetAllUsers interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_GetAllUsers struct {
	item Out_UServ_GetAllUsers
	err  error
}

func newRowUServGetAllUsers(item Out_UServ_GetAllUsers, err error) *Row_UServ_GetAllUsers {
	return &Row_UServ_GetAllUsers{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_GetAllUsers) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_GetAllUsers) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_GetAllUsers) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_SelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_SelectUserById interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_SelectUserById struct {
	item Out_UServ_SelectUserById
	err  error
}

func newRowUServSelectUserById(item Out_UServ_SelectUserById, err error) *Row_UServ_SelectUserById {
	return &Row_UServ_SelectUserById{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_SelectUserById) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_SelectUserById) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_SelectUserById) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_UpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_UpdateUserName interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_UpdateUserName struct {
	item Out_UServ_UpdateUserName
	err  error
}

func newRowUServUpdateUserName(item Out_UServ_UpdateUserName, err error) *Row_UServ_UpdateUserName {
	return &Row_UServ_UpdateUserName{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_UpdateUserName) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_UpdateUserName) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_UpdateUserName) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_UpdateNameToFoo interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Out_UServ_UpdateNameToFoo interface {
}
type Row_UServ_UpdateNameToFoo struct {
	item Out_UServ_UpdateNameToFoo
	err  error
}

func newRowUServUpdateNameToFoo(item Out_UServ_UpdateNameToFoo, err error) *Row_UServ_UpdateNameToFoo {
	return &Row_UServ_UpdateNameToFoo{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_UpdateNameToFoo) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_UpdateNameToFoo) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_UpdateNameToFoo) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_UServ_GetFriends interface {
	GetNames() *SliceStringParam
}
type Out_UServ_GetFriends interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type Row_UServ_GetFriends struct {
	item Out_UServ_GetFriends
	err  error
}

func newRowUServGetFriends(item Out_UServ_GetFriends, err error) *Row_UServ_GetFriends {
	return &Row_UServ_GetFriends{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_GetFriends) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *Row_UServ_GetFriends) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *Row_UServ_GetFriends) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type In_UServ_Drop interface {
}
type Out_UServ_Drop interface {
}
type Row_UServ_Drop struct {
	item Out_UServ_Drop
	err  error
}

func newRowUServDrop(item Out_UServ_Drop, err error) *Row_UServ_Drop {
	return &Row_UServ_Drop{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_UServ_Drop) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_UServ_Drop) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *Row_UServ_Drop) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type Hooks_UServ interface {
	InsertUsersBeforeHook(context.Context, *User) (*Empty2, error)
	GetAllUsersBeforeHook(context.Context, *Empty) (*User, error)
	InsertUsersAfterHook(context.Context, *User, *Empty2) error
	GetAllUsersAfterHook(context.Context, *Empty, *User) error
}
type DefaultHooks_UServ struct{}

func (*DefaultHooks_UServ) InsertUsersBeforeHook(context.Context, *User) (*Empty2, error) {
	return nil, nil
}
func (*DefaultHooks_UServ) GetAllUsersBeforeHook(context.Context, *Empty) (*User, error) {
	return nil, nil
}
func (*DefaultHooks_UServ) InsertUsersAfterHook(context.Context, *User, *Empty2) error {
	return nil
}
func (*DefaultHooks_UServ) GetAllUsersAfterHook(context.Context, *Empty, *User) error {
	return nil
}

type TypeMappings_UServ interface {
	TimestampTimestamp() MappingImpl_UServ_TimestampTimestamp
	SliceStringParam() MappingImpl_UServ_SliceStringParam
}

type DefaultTypeMappings_UServ struct{}

func (this *DefaultTypeMappings_UServ) TimestampTimestamp() MappingImpl_UServ_TimestampTimestamp {
	return &DefaultMappingImpl_UServ_TimestampTimestamp{}
}

type DefaultMappingImpl_UServ_TimestampTimestamp struct{}

func (this *DefaultMappingImpl_UServ_TimestampTimestamp) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) ToSpanner(*timestamp.Timestamp) persist.SpannerScanValuer {
	return this
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) SpannerScan(*spanner.GenericColumnValue) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_TimestampTimestamp) SpannerValue() (interface{}, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_UServ_TimestampTimestamp interface {
	ToProto(**timestamp.Timestamp) error
	ToSpanner(*timestamp.Timestamp) persist.SpannerScanValuer
	SpannerScan(*spanner.GenericColumnValue) error
	SpannerValue() (interface{}, error)
}

func (this *DefaultTypeMappings_UServ) SliceStringParam() MappingImpl_UServ_SliceStringParam {
	return &DefaultMappingImpl_UServ_SliceStringParam{}
}

type DefaultMappingImpl_UServ_SliceStringParam struct{}

func (this *DefaultMappingImpl_UServ_SliceStringParam) ToProto(**SliceStringParam) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) ToSpanner(*SliceStringParam) persist.SpannerScanValuer {
	return this
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) SpannerScan(*spanner.GenericColumnValue) error {
	return nil
}
func (this *DefaultMappingImpl_UServ_SliceStringParam) SpannerValue() (interface{}, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_UServ_SliceStringParam interface {
	ToProto(**SliceStringParam) error
	ToSpanner(*SliceStringParam) persist.SpannerScanValuer
	SpannerScan(*spanner.GenericColumnValue) error
	SpannerValue() (interface{}, error)
}

type Opts_UServ struct {
	MAPPINGS TypeMappings_UServ
	HOOKS    Hooks_UServ
}

func OptsUServ(hooks Hooks_UServ, mappings TypeMappings_UServ) Opts_UServ {
	opts := Opts_UServ{
		HOOKS:    &DefaultHooks_UServ{},
		MAPPINGS: &DefaultTypeMappings_UServ{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_UServ struct {
	opts     *Opts_UServ
	QUERIES  *Queries_UServ
	HANDLERS RestOfHandlers_UServ
	DB       *spanner.Client
}

func ImplUServ(db *spanner.Client, handlers RestOfHandlers_UServ, opts ...Opts_UServ) *Impl_UServ {
	var myOpts Opts_UServ
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsUServ(&DefaultHooks_UServ{}, &DefaultTypeMappings_UServ{})
	}
	return &Impl_UServ{
		opts:     &myOpts,
		QUERIES:  QueriesUServ(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_UServ interface {
	UpdateUserNames(UServ_UpdateUserNamesServer) error
	UpdateAllNames(*Empty, UServ_UpdateAllNamesServer) error
}

func (this *Impl_UServ) UpdateUserNames(stream UServ_UpdateUserNamesServer) error {
	return this.HANDLERS.UpdateUserNames(stream)
}

func (this *Impl_UServ) UpdateAllNames(req *Empty, stream UServ_UpdateAllNamesServer) error {
	return this.HANDLERS.UpdateAllNames(req, stream)
}

func (this *Impl_UServ) CreateTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.CreateUsersTable(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) InsertUsers(stream UServ_InsertUsersServer) error {
	if err := this.InsertUsersTx(stream); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'insert_users' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) InsertUsersTx(stream UServ_InsertUsersServer) error {
	items := make([]*User, 0)
	var first *User
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		{
			beforeRes, err := this.opts.HOOKS.InsertUsersBeforeHook(stream.Context(), req)
			if err != nil {
				return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
			} else if beforeRes != nil {
				continue
			}
		}

		items = append(items, req)
	}
	_, err := this.DB.ReadWriteTransaction(stream.Context(), func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
		for _, item := range items {
			query := this.QUERIES.InsertUsers(ctx, tx)
			result := query.Execute(item)
			if err := result.Zero(); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in read write transaction: %v", err)
	}
	res := &Empty2{}

	{
		if err := this.opts.HOOKS.InsertUsersAfterHook(stream.Context(), first, res); err != nil {
			return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
		}
	}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

func (this *Impl_UServ) GetAllUsers(req *Empty, stream UServ_GetAllUsersServer) error {
	if err := this.GetAllUsersTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_all_users' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) GetAllUsersTx(req *Empty, stream UServ_GetAllUsersServer, tx persist.SpannerRunnable) error {
	ctx := stream.Context()
	query := this.QUERIES.GetAllUsers(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_UServ_GetAllUsers) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_UServ) SelectUserById(ctx context.Context, req *User) (*User, error) {
	query := this.QUERIES.SelectUserById(ctx, this.DB.Single())

	result := query.Execute(req)
	res, err := result.One().User()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) UpdateNameToFoo(ctx context.Context, req *User) (*Empty, error) {
	query := this.QUERIES.UpdateNameToFoo(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_UServ) GetFriends(req *FriendsReq, stream UServ_GetFriendsServer) error {
	if err := this.GetFriendsTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_friends' query: %v", err)
	}
	return nil
}
func (this *Impl_UServ) GetFriendsTx(req *FriendsReq, stream UServ_GetFriendsServer, tx persist.SpannerRunnable) error {
	ctx := stream.Context()
	query := this.QUERIES.GetFriends(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_UServ_GetFriends) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_UServ) DropTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.Drop(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}
