package main

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"net"
	"time"

	"github.com/lib/pq"
	pb "github.com/tcncloud/protoc-gen-persistdocs/test"
	"google.golang.org/grpc"
)

func main() {
	db, err := sql.Open("postgres", "user=postgres password=postgres dbname=postgres sslmode=disable")
	if err != nil {
		panic(err)
	}
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

	defer cancel()

	// gain access to the struct that can run this query.
	// 'db' can be anything that satisfies this interface
	/*
		type Runnable interface {
			QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
			ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
		}
	*/
	catQuery := pb.QueriesPetShop().GetCatByName(ctx, db)

	// look for the cat that matches this protobuf's cat_name field
	catName := &pb.CatName{CatName: "boomi"}

	// 'Execute' will always return an iterator.
	iter := catQuery.Execute(catName)

	// you can loop through an iterator calling `Next()`
	// ok will be true if there is something next can return besides EOF
	for {
		row, ok := iter.Next()
		if !ok {
			break
		}
		// you can get the protobuf, and any defered error by calling 'Proto'
		cat, err := row.Proto()

		fmt.Printf("#+v\n", cat)
	}

	// you can loop through an iterator calling Each()
	err = iter.Each(func(row *pb.Row_PetShop_GetCatByName) error {
		// if you have an initialized proto to use already, you can just call unwrap
		cat := pb.Cat{}
		if err := row.Unwrap(&cat); err != nil {
			return err
		}
		// use 'cat'
		fmt.Printf("#+v\n", cat)

		return nil
	})

	// you can assert that an iterator has no results or errors with Zero(), which will error out if there
	// is more than zero rows, or there is an error
	err = iter.Zero()

	// you can assert that an iterator has exactly one result with One(), which will always return one row.
	// The row will always be an error if there is more or less than one result
	row := iter.One()
	// each row will also have the name of the output proto as a dup method of Proto() for clarity

	cat, err := row.Cat()

}

func main2() {
	db, err := sql.Open("postgres", "user=postgres password=postgres dbname=postgres sslmode=disable")
	if err != nil {
		panic(err)
	}
	// we couldnt have the PetDog Handler generated, so we have to have
	// a struct that implements it as a method
	handlers := &MyPartOfPetShop{}

	// 'ImplPetShop' gets the *FULL* handler implementation of our service handlers.
	service := pb.ImplPetShop(db, handlers)

	// create a grpc server
	server := grpc.NewServer()

	// register our service on our server
	pb.RegisterPetShopServer(server, service)

	lis, err := net.Listen("tcp", "0.0.0.0:50051")
	if err != nil {
		panic(err)
	}
	if err := server.Serve(lis); err != nil {
		fmt.Printf("error serving: %v\n", err)
	}
}

// This struct implements PetDog, but it it does not need to implement GetCatByName, or ShipFish.
// Those methods are generated by persist.
type MyPartOfPetShop struct{}

func (m *MyPartOfPetShop) PetDog(ctx context.Context, req *pb.Dog) (*pb.Empty, error) {

	// ...

	return &pb.Empty{}, nil
}

func main3() {
	db, err := sql.Open("postgres", "user=postgres password=postgres dbname=postgres sslmode=disable")
	if err != nil {
		panic(err)
	}
	var owners *pb.Owner
	// create an instance of our TypeMapping initializer interface `MyMapper`
	// since we are about to perform a query that uses mapped types, we must create these options
	// to initialize the query with
	opts := pb.OptsPetShop(nil, &MyMapper{})
	// pass opts to the queries constructor.  Anything using this query handler will now use the opts above
	pb.QueriesPetShop(opts).GetAllOwners(ctx, db).Execute().Each(func(row *pb.Row_PetShop_GetAllOwners) error {
		// make an instance of our result
		owner := pb.Owner{}
		// pass to unwrap
		if err := row.Unwrap(&owner); err != nil {
			return err
		}
		// store with rest of owners
		owners = append(owners, owner)

		return nil
	})
	// owners has been successfully mapped
}

// this implements the 'TypeMappings_PetShop` interface
type MyMapper struct{}

func (m *MyMapper) DogIds() pb.MappingImpl_PetShop_DogIds {
	// return a new instance of our `DogIds` Mapper
	return &DogIder{}
}

// This implements the MappingImpl_PetShop_DogIds interface
type DogIder struct {
	// we will need to store this
	ids *pb.DogIds
}

// ToProto will *only* be called after a call to Scan on the same instance.
// ToProto expects the struct to set its internal parsed proto value from scan into dest (*dest = this.ids)
func (this *DogIder) ToProto(dest **pb.DogIds) error {
	*dest = this.ids
	return nil
}

// ToSql initializes the implementation with a value.  It expects its return value
// to be able to scan out our request as a type that will fit in the db column
func (this *DogIder) ToSql(request *pb.DogIds) sql.Scanner {
	this.ids = request
	return this
}

// given this arbitrary value, scan needs to populate its internal state so a call to `ToProto` or `Value`
// will return `value` correctly
func (this *DogIder) Scan(value interface{}) error {
	// lib/pq is the driver we use for postgres at TCN. It implments scanner and valuer.
	var in pq.StringArray
	if err := in.Scan(src); err != nil {
		return err
	}
	in.ids = &pb.DogIds{Values: []string(in)}
	return nil
}

// it needs to return its internal value as one that can fit in database/sql driver.Valuer interface
func (this *DogIder) Value() (driver.Value, error) {
	// grab the nested string slice field, hand to pq, return it's call Value()
	return pq.StringArray(this.ids.Values).Value()
}
