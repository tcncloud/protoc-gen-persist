// This file is generated by protoc-gen-persist
// Source File: tests/spanner/basic/basic_example.proto
// DO NOT EDIT !
package basic

import (
	fmt "fmt"
	io "io"

	spanner "cloud.google.com/go/spanner"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	persist "github.com/tcncloud/protoc-gen-persist/persist"
	test "github.com/tcncloud/protoc-gen-persist/tests/test"
	context "golang.org/x/net/context"
	iterator "google.golang.org/api/iterator"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type Result interface {
	LastInsertId() (int64, error)
	RowsAffected() (int64, error)
}
type SpannerResult struct {
	// TODO shouldn't be an iter
	iter *spanner.RowIterator
}

func (sr *SpannerResult) LastInsertId() (int64, error) {
	// sr.iter.QueryStats or sr.iter.QueryPlan
	return -1, nil
}
func (sr *SpannerResult) RowsAffected() (int64, error) {
	// Execution statistics for the query. Available after RowIterator.Next returns iterator.Done
	return sr.iter.RowCount, nil
}

// Queries_ExtraSrv holds all the queries found the proto service option as methods
type Queries_ExtraSrv struct {
	opts Opts_ExtraSrv
}

// QueriesExtraSrv returns all the known 'SQL' queires for the 'ExtraSrv' service.
// If no opts are provided default implementations are used.
func QueriesExtraSrv(opts ...Opts_ExtraSrv) *Queries_ExtraSrv {
	var myOpts Opts_ExtraSrv
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsExtraSrv(&DefaultHooks_ExtraSrv{}, &DefaultTypeMappings_ExtraSrv{})
	}
	return &Queries_ExtraSrv{
		opts: myOpts,
	}
}

// Extra returns a struct that will perform the 'extra' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_ExtraSrv) Extra(ctx context.Context, db persist.SpannerRunnable) *Query_ExtraSrv_Extra {
	return &Query_ExtraSrv_Extra{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_ExtraSrv_Extra (future doc string needed)
type Query_ExtraSrv_Extra struct {
	opts Opts_ExtraSrv
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_ExtraSrv_Extra) QueryInType_Empty()         {}
func (this *Query_ExtraSrv_Extra) QueryOutType_HasTimestamp() {}

// Executes the query 'extra' with parameters retrieved from x.
// Fields used: []
func (this *Query_ExtraSrv_Extra) Execute(x In_ExtraSrv_Extra) *Iter_ExtraSrv_Extra {
	ctx := this.ctx
	result := &Iter_ExtraSrv_Extra{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT * FROM extra_unary",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

type Iter_ExtraSrv_Extra struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_ExtraSrv
	ctx    context.Context
}

func (this *Iter_ExtraSrv_Extra) IterOutTypeHasTimestamp() {}
func (this *Iter_ExtraSrv_Extra) IterInTypeEmpty()         {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_ExtraSrv_Extra) Each(fun func(*Row_ExtraSrv_Extra) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_ExtraSrv_Extra) One() *Row_ExtraSrv_Extra {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_ExtraSrv_Extra{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("expected exactly 1 result from query 'Extra' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_ExtraSrv_Extra) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Extra'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_ExtraSrv_Extra) Next() (*Row_ExtraSrv_Extra, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_ExtraSrv_Extra{err: err}, true
	}

	time := &timestamp.Timestamp{}
	timeBytes := make([]byte, 0)
	if err := row.ColumnByName("time", &timeBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column time to []byte")}, true
	}
	if err := proto.Unmarshal(timeBytes, time); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column time to proto message")}, true
	}

	some := &Something{}
	someBytes := make([]byte, 0)
	if err := row.ColumnByName("some", &someBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column some to []byte")}, true
	}
	if err := proto.Unmarshal(someBytes, some); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column some to proto message")}, true
	}

	var str string
	if err := row.ColumnByName("str", &str); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("cant convert db column str to protobuf go type string")}, true
	}

	table := &test.ExampleTable{}
	tableBytes := make([]byte, 0)
	if err := row.ColumnByName("table", &tableBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column table to []byte")}, true
	}
	if err := proto.Unmarshal(tableBytes, table); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column table to proto message")}, true
	}

	var strs []string
	if err := row.ColumnByName("strs", &strs); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("cant convert db column strs to protobuf go type []string")}, true
	}

	tables := make([]*test.ExampleTable, 0)
	tablesBytes := make([][]byte, 0)
	if err := row.ColumnByName("tables", &tablesBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column tables to [][]byte")}, true
	}
	for _, x := range tablesBytes {
		tmp := &test.ExampleTable{}
		if err := proto.Unmarshal(x, tmp); err != nil {
			return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column table to proto message")}, true
		}
		tables = append(tables, tmp)
	}

	somes := make([]*Something, 0)
	somesBytes := make([][]byte, 0)
	if err := row.ColumnByName("somes", &somesBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column somes to [][]byte")}, true
	}
	for _, x := range somesBytes {
		tmp := &Something{}
		if err := proto.Unmarshal(x, tmp); err != nil {
			return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column table to proto message")}, true
		}
		somes = append(somes, tmp)
	}

	times := make([]*timestamp.Timestamp, 0)
	timesBytes := make([][]byte, 0)
	if err := row.ColumnByName("times", &timesBytes); err != nil {
		return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to convert db column times to [][]byte")}, true
	}
	for _, x := range timesBytes {
		tmp := &timestamp.Timestamp{}
		if err := proto.Unmarshal(x, tmp); err != nil {
			return &Row_ExtraSrv_Extra{err: fmt.Errorf("failed to unmarshal column table to proto message")}, true
		}
		times = append(times, tmp)
	}

	res := &HasTimestamp{
		Time:   time,
		Some:   some,
		Str:    str,
		Table:  table,
		Strs:   strs,
		Tables: tables,
		Somes:  somes,
		Times:  times,
	}
	return &Row_ExtraSrv_Extra{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_ExtraSrv_Extra) Slice() []*Row_ExtraSrv_Extra {
	var results []*Row_ExtraSrv_Extra
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type In_ExtraSrv_Extra interface {
}
type Out_ExtraSrv_Extra interface {
	GetTime() *timestamp.Timestamp
	GetSome() *Something
	GetStr() string
	GetTable() *test.ExampleTable
	GetStrs() []string
	GetTables() []*test.ExampleTable
	GetSomes() []*Something
	GetTimes() []*timestamp.Timestamp
}
type Row_ExtraSrv_Extra struct {
	item Out_ExtraSrv_Extra
	err  error
}

func newRowExtraSrvExtra(item Out_ExtraSrv_Extra, err error) *Row_ExtraSrv_Extra {
	return &Row_ExtraSrv_Extra{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_ExtraSrv_Extra) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*HasTimestamp); ok {
		if o == nil {
			return fmt.Errorf("must initialize *HasTimestamp before giving to Unwrap()")
		}
		res, _ := this.HasTimestamp()
		_ = res
		o.Time = res.Time
		o.Some = res.Some
		o.Str = res.Str
		o.Table = res.Table
		o.Strs = res.Strs
		o.Tables = res.Tables
		o.Somes = res.Somes
		o.Times = res.Times
		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_ExtraSrv_Extra) HasTimestamp() (*HasTimestamp, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &HasTimestamp{
		Time:   this.item.GetTime(),
		Some:   this.item.GetSome(),
		Str:    this.item.GetStr(),
		Table:  this.item.GetTable(),
		Strs:   this.item.GetStrs(),
		Tables: this.item.GetTables(),
		Somes:  this.item.GetSomes(),
		Times:  this.item.GetTimes(),
	}, nil
}
func (this *Row_ExtraSrv_Extra) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{}, nil
}

func (this *Row_ExtraSrv_Extra) Proto() (*HasTimestamp, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &HasTimestamp{
		Time:   this.item.GetTime(),
		Some:   this.item.GetSome(),
		Str:    this.item.GetStr(),
		Table:  this.item.GetTable(),
		Strs:   this.item.GetStrs(),
		Tables: this.item.GetTables(),
		Somes:  this.item.GetSomes(),
		Times:  this.item.GetTimes(),
	}, nil
}

type Hooks_ExtraSrv interface {
}
type DefaultHooks_ExtraSrv struct{}
type TypeMappings_ExtraSrv interface {
}
type DefaultTypeMappings_ExtraSrv struct{}

type Opts_ExtraSrv struct {
	MAPPINGS TypeMappings_ExtraSrv
	HOOKS    Hooks_ExtraSrv
}

func OptsExtraSrv(hooks Hooks_ExtraSrv, mappings TypeMappings_ExtraSrv) Opts_ExtraSrv {
	opts := Opts_ExtraSrv{
		HOOKS:    &DefaultHooks_ExtraSrv{},
		MAPPINGS: &DefaultTypeMappings_ExtraSrv{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_ExtraSrv struct {
	opts     *Opts_ExtraSrv
	QUERIES  *Queries_ExtraSrv
	HANDLERS RestOfHandlers_ExtraSrv
	DB       *spanner.Client
}

func ImplExtraSrv(db *spanner.Client, handlers RestOfHandlers_ExtraSrv, opts ...Opts_ExtraSrv) *Impl_ExtraSrv {
	var myOpts Opts_ExtraSrv
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsExtraSrv(&DefaultHooks_ExtraSrv{}, &DefaultTypeMappings_ExtraSrv{})
	}
	return &Impl_ExtraSrv{
		opts:     &myOpts,
		QUERIES:  QueriesExtraSrv(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_ExtraSrv interface {
	ExtraMethod(context.Context, *test.ExampleTable) (*test.ExampleTable, error)
}

func (this *Impl_ExtraSrv) ExtraMethod(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	return this.HANDLERS.ExtraMethod(ctx, req)
}

func (this *Impl_ExtraSrv) ExtraUnary(ctx context.Context, req *test.NumRows) (*test.ExampleTable, error) {
	query := this.QUERIES.Extra(ctx, this.DB.Single())

	result := query.Execute(req)
	res, err := result.One().TestExampleTable()
	if err != nil {
		return nil, err
	}

	return res, nil
}

// Queries_MySpanner holds all the queries found the proto service option as methods
type Queries_MySpanner struct {
	opts Opts_MySpanner
}

// QueriesMySpanner returns all the known 'SQL' queires for the 'MySpanner' service.
// If no opts are provided default implementations are used.
func QueriesMySpanner(opts ...Opts_MySpanner) *Queries_MySpanner {
	var myOpts Opts_MySpanner
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsMySpanner(&DefaultHooks_MySpanner{}, &DefaultTypeMappings_MySpanner{})
	}
	return &Queries_MySpanner{
		opts: myOpts,
	}
}

// Insert returns a struct that will perform the 'insert' query.
// When Execute is called, it will use the following fields:
// [id start_time]
func (this *Queries_MySpanner) Insert(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_Insert {
	return &Query_MySpanner_Insert{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_Insert (future doc string needed)
type Query_MySpanner_Insert struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_Insert) QueryInType_ExampleTable() {}
func (this *Query_MySpanner_Insert) QueryOutType_Empty()       {}

// Executes the query 'insert' with parameters retrieved from x.
// Fields used: [id start_time]
func (this *Query_MySpanner_Insert) Execute(x In_MySpanner_Insert) *Iter_MySpanner_Insert {
	ctx := this.ctx
	result := &Iter_MySpanner_Insert{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		start_time, err := proto.Marshal(x.GetStartTime())
		if err != nil {
			return nil, err
		}
		result["start_time"] = start_time
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "Insert into example_table (id, start_time, name) Values (@id, @start_time, 'bananas')",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// Select returns a struct that will perform the 'select' query.
// When Execute is called, it will use the following fields:
// [id name]
func (this *Queries_MySpanner) Select(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_Select {
	return &Query_MySpanner_Select{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_Select (future doc string needed)
type Query_MySpanner_Select struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_Select) QueryInType_ExampleTable()  {}
func (this *Query_MySpanner_Select) QueryOutType_ExampleTable() {}

// Executes the query 'select' with parameters retrieved from x.
// Fields used: [id name]
func (this *Query_MySpanner_Select) Execute(x In_MySpanner_Select) *Iter_MySpanner_Select {
	ctx := this.ctx
	result := &Iter_MySpanner_Select{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		result["name"] = x.GetName()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT * from example_table Where id=@id AND name=@name",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// SelectIndex returns a struct that will perform the 'select_index' query.
// When Execute is called, it will use the following fields:
// [id name]
func (this *Queries_MySpanner) SelectIndex(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_SelectIndex {
	return &Query_MySpanner_SelectIndex{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_SelectIndex (future doc string needed)
type Query_MySpanner_SelectIndex struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_SelectIndex) QueryInType_ExampleTable()  {}
func (this *Query_MySpanner_SelectIndex) QueryOutType_ExampleTable() {}

// Executes the query 'select_index' with parameters retrieved from x.
// Fields used: [id name]
func (this *Query_MySpanner_SelectIndex) Execute(x In_MySpanner_SelectIndex) *Iter_MySpanner_SelectIndex {
	ctx := this.ctx
	result := &Iter_MySpanner_SelectIndex{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		result["name"] = x.GetName()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT * from example_table@{FORCE_INDEX=index} Where id=@id AND name=@name",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// Update returns a struct that will perform the 'update' query.
// When Execute is called, it will use the following fields:
// [start_time id]
func (this *Queries_MySpanner) Update(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_Update {
	return &Query_MySpanner_Update{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_Update (future doc string needed)
type Query_MySpanner_Update struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_Update) QueryInType_ExampleTable() {}
func (this *Query_MySpanner_Update) QueryOutType_Empty()       {}

// Executes the query 'update' with parameters retrieved from x.
// Fields used: [start_time id]
func (this *Query_MySpanner_Update) Execute(x In_MySpanner_Update) *Iter_MySpanner_Update {
	ctx := this.ctx
	result := &Iter_MySpanner_Update{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		start_time, err := proto.Marshal(x.GetStartTime())
		if err != nil {
			return nil, err
		}
		result["start_time"] = start_time
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "Update example_table  set start_time=@start_time, name='oranges' PrimaryKey(id=@id)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// Delete returns a struct that will perform the 'delete' query.
// When Execute is called, it will use the following fields:
// [start_id end_id]
func (this *Queries_MySpanner) Delete(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_Delete {
	return &Query_MySpanner_Delete{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_Delete (future doc string needed)
type Query_MySpanner_Delete struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_Delete) QueryInType_ExampleTableRange() {}
func (this *Query_MySpanner_Delete) QueryOutType_Empty()            {}

// Executes the query 'delete' with parameters retrieved from x.
// Fields used: [start_id end_id]
func (this *Query_MySpanner_Delete) Execute(x In_MySpanner_Delete) *Iter_MySpanner_Delete {
	ctx := this.ctx
	result := &Iter_MySpanner_Delete{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["start_id"] = x.GetStartId()
		result["end_id"] = x.GetEndId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "DELETE FROM example_table START(@start_id) END(@end_id) KIND(CO)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// SelectAll returns a struct that will perform the 'select_all' query.
// When Execute is called, it will use the following fields:
// []
func (this *Queries_MySpanner) SelectAll(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_SelectAll {
	return &Query_MySpanner_SelectAll{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_SelectAll (future doc string needed)
type Query_MySpanner_SelectAll struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_SelectAll) QueryInType_Empty()         {}
func (this *Query_MySpanner_SelectAll) QueryOutType_ExampleTable() {}

// Executes the query 'select_all' with parameters retrieved from x.
// Fields used: []
func (this *Query_MySpanner_SelectAll) Execute(x In_MySpanner_SelectAll) *Iter_MySpanner_SelectAll {
	ctx := this.ctx
	result := &Iter_MySpanner_SelectAll{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT * FROM example_table",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// Insert_3 returns a struct that will perform the 'insert_3' query.
// When Execute is called, it will use the following fields:
// [id start_time]
func (this *Queries_MySpanner) Insert_3(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_Insert_3 {
	return &Query_MySpanner_Insert_3{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_Insert_3 (future doc string needed)
type Query_MySpanner_Insert_3 struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_Insert_3) QueryInType_ExampleTable() {}
func (this *Query_MySpanner_Insert_3) QueryOutType_Empty()       {}

// Executes the query 'insert_3' with parameters retrieved from x.
// Fields used: [id start_time]
func (this *Query_MySpanner_Insert_3) Execute(x In_MySpanner_Insert_3) *Iter_MySpanner_Insert_3 {
	ctx := this.ctx
	result := &Iter_MySpanner_Insert_3{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		start_time, err := proto.Marshal(x.GetStartTime())
		if err != nil {
			return nil, err
		}
		result["start_time"] = start_time
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "INSERT INTO example_table (id, start_time, name) VALUES (@id, @start_time, 3)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// DeleteId returns a struct that will perform the 'delete_id' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_MySpanner) DeleteId(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_DeleteId {
	return &Query_MySpanner_DeleteId{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_DeleteId (future doc string needed)
type Query_MySpanner_DeleteId struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_DeleteId) QueryInType_ExampleTable() {}
func (this *Query_MySpanner_DeleteId) QueryOutType_Empty()       {}

// Executes the query 'delete_id' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_MySpanner_DeleteId) Execute(x In_MySpanner_DeleteId) *Iter_MySpanner_DeleteId {
	ctx := this.ctx
	result := &Iter_MySpanner_DeleteId{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "DELETE FROM example_table VALUES(@id)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// SetNameAsdf returns a struct that will perform the 'set_name_asdf' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_MySpanner) SetNameAsdf(ctx context.Context, db persist.SpannerRunnable) *Query_MySpanner_SetNameAsdf {
	return &Query_MySpanner_SetNameAsdf{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_MySpanner_SetNameAsdf (future doc string needed)
type Query_MySpanner_SetNameAsdf struct {
	opts Opts_MySpanner
	db   persist.SpannerRunnable
	ctx  context.Context
}

func (this *Query_MySpanner_SetNameAsdf) QueryInType_ExampleTable() {}
func (this *Query_MySpanner_SetNameAsdf) QueryOutType_Empty()       {}

// Executes the query 'set_name_asdf' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_MySpanner_SetNameAsdf) Execute(x In_MySpanner_SetNameAsdf) *Iter_MySpanner_SetNameAsdf {
	ctx := this.ctx
	result := &Iter_MySpanner_SetNameAsdf{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "update example_table set name='asdf' pk(id=@id)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

type Iter_MySpanner_Insert struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_Insert) IterOutTypeEmpty()           {}
func (this *Iter_MySpanner_Insert) IterInTypeTestExampleTable() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_Insert) Each(fun func(*Row_MySpanner_Insert) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_Insert) One() *Row_MySpanner_Insert {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_Insert{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_Insert{err: fmt.Errorf("expected exactly 1 result from query 'Insert' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_Insert) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Insert'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_Insert) Next() (*Row_MySpanner_Insert, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_Insert{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_Insert{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_Insert) Slice() []*Row_MySpanner_Insert {
	var results []*Row_MySpanner_Insert
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_Select struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_Select) IterOutTypeTestExampleTable() {}
func (this *Iter_MySpanner_Select) IterInTypeTestExampleTable()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_Select) Each(fun func(*Row_MySpanner_Select) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_Select) One() *Row_MySpanner_Select {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_Select{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_Select{err: fmt.Errorf("expected exactly 1 result from query 'Select' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_Select) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Select'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_Select) Next() (*Row_MySpanner_Select, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_Select{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_MySpanner_Select{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	start_time := &timestamp.Timestamp{}
	start_timeBytes := make([]byte, 0)
	if err := row.ColumnByName("start_time", &start_timeBytes); err != nil {
		return &Row_MySpanner_Select{err: fmt.Errorf("failed to convert db column start_time to []byte")}, true
	}
	if err := proto.Unmarshal(start_timeBytes, start_time); err != nil {
		return &Row_MySpanner_Select{err: fmt.Errorf("failed to unmarshal column start_time to proto message")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_MySpanner_Select{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	res := &test.ExampleTable{
		Id:        id,
		StartTime: start_time,
		Name:      name,
	}
	return &Row_MySpanner_Select{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_Select) Slice() []*Row_MySpanner_Select {
	var results []*Row_MySpanner_Select
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_SelectIndex struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_SelectIndex) IterOutTypeTestExampleTable() {}
func (this *Iter_MySpanner_SelectIndex) IterInTypeTestExampleTable()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_SelectIndex) Each(fun func(*Row_MySpanner_SelectIndex) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_SelectIndex) One() *Row_MySpanner_SelectIndex {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_SelectIndex{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_SelectIndex{err: fmt.Errorf("expected exactly 1 result from query 'SelectIndex' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_SelectIndex) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SelectIndex'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_SelectIndex) Next() (*Row_MySpanner_SelectIndex, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_SelectIndex{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_MySpanner_SelectIndex{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	start_time := &timestamp.Timestamp{}
	start_timeBytes := make([]byte, 0)
	if err := row.ColumnByName("start_time", &start_timeBytes); err != nil {
		return &Row_MySpanner_SelectIndex{err: fmt.Errorf("failed to convert db column start_time to []byte")}, true
	}
	if err := proto.Unmarshal(start_timeBytes, start_time); err != nil {
		return &Row_MySpanner_SelectIndex{err: fmt.Errorf("failed to unmarshal column start_time to proto message")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_MySpanner_SelectIndex{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	res := &test.ExampleTable{
		Id:        id,
		StartTime: start_time,
		Name:      name,
	}
	return &Row_MySpanner_SelectIndex{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_SelectIndex) Slice() []*Row_MySpanner_SelectIndex {
	var results []*Row_MySpanner_SelectIndex
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_Update struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_Update) IterOutTypeEmpty()           {}
func (this *Iter_MySpanner_Update) IterInTypeTestExampleTable() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_Update) Each(fun func(*Row_MySpanner_Update) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_Update) One() *Row_MySpanner_Update {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_Update{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_Update{err: fmt.Errorf("expected exactly 1 result from query 'Update' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_Update) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Update'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_Update) Next() (*Row_MySpanner_Update, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_Update{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_Update{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_Update) Slice() []*Row_MySpanner_Update {
	var results []*Row_MySpanner_Update
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_Delete struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_Delete) IterOutTypeEmpty()                {}
func (this *Iter_MySpanner_Delete) IterInTypeTestExampleTableRange() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_Delete) Each(fun func(*Row_MySpanner_Delete) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_Delete) One() *Row_MySpanner_Delete {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_Delete{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_Delete{err: fmt.Errorf("expected exactly 1 result from query 'Delete' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_Delete) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Delete'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_Delete) Next() (*Row_MySpanner_Delete, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_Delete{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_Delete{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_Delete) Slice() []*Row_MySpanner_Delete {
	var results []*Row_MySpanner_Delete
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_SelectAll struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_SelectAll) IterOutTypeTestExampleTable() {}
func (this *Iter_MySpanner_SelectAll) IterInTypeEmpty()             {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_SelectAll) Each(fun func(*Row_MySpanner_SelectAll) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_SelectAll) One() *Row_MySpanner_SelectAll {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_SelectAll{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_SelectAll{err: fmt.Errorf("expected exactly 1 result from query 'SelectAll' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_SelectAll) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SelectAll'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_SelectAll) Next() (*Row_MySpanner_SelectAll, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_SelectAll{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &Row_MySpanner_SelectAll{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	start_time := &timestamp.Timestamp{}
	start_timeBytes := make([]byte, 0)
	if err := row.ColumnByName("start_time", &start_timeBytes); err != nil {
		return &Row_MySpanner_SelectAll{err: fmt.Errorf("failed to convert db column start_time to []byte")}, true
	}
	if err := proto.Unmarshal(start_timeBytes, start_time); err != nil {
		return &Row_MySpanner_SelectAll{err: fmt.Errorf("failed to unmarshal column start_time to proto message")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &Row_MySpanner_SelectAll{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	res := &test.ExampleTable{
		Id:        id,
		StartTime: start_time,
		Name:      name,
	}
	return &Row_MySpanner_SelectAll{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_SelectAll) Slice() []*Row_MySpanner_SelectAll {
	var results []*Row_MySpanner_SelectAll
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_Insert_3 struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_Insert_3) IterOutTypeEmpty()           {}
func (this *Iter_MySpanner_Insert_3) IterInTypeTestExampleTable() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_Insert_3) Each(fun func(*Row_MySpanner_Insert_3) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_Insert_3) One() *Row_MySpanner_Insert_3 {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_Insert_3{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_Insert_3{err: fmt.Errorf("expected exactly 1 result from query 'Insert_3' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_Insert_3) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Insert_3'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_Insert_3) Next() (*Row_MySpanner_Insert_3, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_Insert_3{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_Insert_3{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_Insert_3) Slice() []*Row_MySpanner_Insert_3 {
	var results []*Row_MySpanner_Insert_3
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_DeleteId struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_DeleteId) IterOutTypeEmpty()           {}
func (this *Iter_MySpanner_DeleteId) IterInTypeTestExampleTable() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_DeleteId) Each(fun func(*Row_MySpanner_DeleteId) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_DeleteId) One() *Row_MySpanner_DeleteId {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_DeleteId{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_DeleteId{err: fmt.Errorf("expected exactly 1 result from query 'DeleteId' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_DeleteId) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'DeleteId'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_DeleteId) Next() (*Row_MySpanner_DeleteId, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_DeleteId{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_DeleteId{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_DeleteId) Slice() []*Row_MySpanner_DeleteId {
	var results []*Row_MySpanner_DeleteId
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type Iter_MySpanner_SetNameAsdf struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     TypeMappings_MySpanner
	ctx    context.Context
}

func (this *Iter_MySpanner_SetNameAsdf) IterOutTypeEmpty()           {}
func (this *Iter_MySpanner_SetNameAsdf) IterInTypeTestExampleTable() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_MySpanner_SetNameAsdf) Each(fun func(*Row_MySpanner_SetNameAsdf) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_MySpanner_SetNameAsdf) One() *Row_MySpanner_SetNameAsdf {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil {
		return &Row_MySpanner_SetNameAsdf{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_MySpanner_SetNameAsdf{err: fmt.Errorf("expected exactly 1 result from query 'SetNameAsdf' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_MySpanner_SetNameAsdf) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SetNameAsdf'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_MySpanner_SetNameAsdf) Next() (*Row_MySpanner_SetNameAsdf, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &Row_MySpanner_SetNameAsdf{err: err}, true
	}
	res := &Empty{}
	return &Row_MySpanner_SetNameAsdf{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_MySpanner_SetNameAsdf) Slice() []*Row_MySpanner_SetNameAsdf {
	var results []*Row_MySpanner_SetNameAsdf
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type In_MySpanner_Insert interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_Insert interface {
}
type Row_MySpanner_Insert struct {
	item Out_MySpanner_Insert
	err  error
}

func newRowMySpannerInsert(item Out_MySpanner_Insert, err error) *Row_MySpanner_Insert {
	return &Row_MySpanner_Insert{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_Insert) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_Insert) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_Insert) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{}, nil
}

func (this *Row_MySpanner_Insert) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_MySpanner_Select interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_Select interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Row_MySpanner_Select struct {
	item Out_MySpanner_Select
	err  error
}

func newRowMySpannerSelect(item Out_MySpanner_Select, err error) *Row_MySpanner_Select {
	return &Row_MySpanner_Select{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_Select) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	return nil
}
func (this *Row_MySpanner_Select) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

func (this *Row_MySpanner_Select) Proto() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

type In_MySpanner_SelectIndex interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_SelectIndex interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Row_MySpanner_SelectIndex struct {
	item Out_MySpanner_SelectIndex
	err  error
}

func newRowMySpannerSelectIndex(item Out_MySpanner_SelectIndex, err error) *Row_MySpanner_SelectIndex {
	return &Row_MySpanner_SelectIndex{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_SelectIndex) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}
	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	return nil
}
func (this *Row_MySpanner_SelectIndex) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

func (this *Row_MySpanner_SelectIndex) Proto() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

type In_MySpanner_Update interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_Update interface {
}
type Row_MySpanner_Update struct {
	item Out_MySpanner_Update
	err  error
}

func newRowMySpannerUpdate(item Out_MySpanner_Update, err error) *Row_MySpanner_Update {
	return &Row_MySpanner_Update{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_Update) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.PartialTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.PartialTable before giving to Unwrap()")
		}
		res, _ := this.TestPartialTable()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_Update) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_Update) TestPartialTable() (*test.PartialTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.PartialTable{}, nil
}

func (this *Row_MySpanner_Update) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_MySpanner_Delete interface {
	GetStartId() int64
	GetEndId() int64
}
type Out_MySpanner_Delete interface {
}
type Row_MySpanner_Delete struct {
	item Out_MySpanner_Delete
	err  error
}

func newRowMySpannerDelete(item Out_MySpanner_Delete, err error) *Row_MySpanner_Delete {
	return &Row_MySpanner_Delete{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_Delete) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_Delete) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_Delete) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{}, nil
}

func (this *Row_MySpanner_Delete) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_MySpanner_SelectAll interface {
}
type Out_MySpanner_SelectAll interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Row_MySpanner_SelectAll struct {
	item Out_MySpanner_SelectAll
	err  error
}

func newRowMySpannerSelectAll(item Out_MySpanner_SelectAll, err error) *Row_MySpanner_SelectAll {
	return &Row_MySpanner_SelectAll{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_SelectAll) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}
	if o, ok := (pointerToMsg).(*test.ExampleTable); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.ExampleTable before giving to Unwrap()")
		}
		res, _ := this.TestExampleTable()
		_ = res
		o.Id = res.Id
		o.StartTime = res.StartTime
		o.Name = res.Name
		return nil
	}

	return nil
}
func (this *Row_MySpanner_SelectAll) TestExampleTable() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

func (this *Row_MySpanner_SelectAll) Proto() (*test.ExampleTable, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.ExampleTable{
		Id:        this.item.GetId(),
		StartTime: this.item.GetStartTime(),
		Name:      this.item.GetName(),
	}, nil
}

type In_MySpanner_Insert_3 interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_Insert_3 interface {
}
type Row_MySpanner_Insert_3 struct {
	item Out_MySpanner_Insert_3
	err  error
}

func newRowMySpannerInsert_3(item Out_MySpanner_Insert_3, err error) *Row_MySpanner_Insert_3 {
	return &Row_MySpanner_Insert_3{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_Insert_3) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.NumRows); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.NumRows before giving to Unwrap()")
		}
		res, _ := this.TestNumRows()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_Insert_3) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_Insert_3) TestNumRows() (*test.NumRows, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.NumRows{}, nil
}

func (this *Row_MySpanner_Insert_3) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_MySpanner_DeleteId interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_DeleteId interface {
}
type Row_MySpanner_DeleteId struct {
	item Out_MySpanner_DeleteId
	err  error
}

func newRowMySpannerDeleteId(item Out_MySpanner_DeleteId, err error) *Row_MySpanner_DeleteId {
	return &Row_MySpanner_DeleteId{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_DeleteId) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.NumRows); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.NumRows before giving to Unwrap()")
		}
		res, _ := this.TestNumRows()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_DeleteId) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_DeleteId) TestNumRows() (*test.NumRows, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.NumRows{}, nil
}

func (this *Row_MySpanner_DeleteId) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type In_MySpanner_SetNameAsdf interface {
	GetId() int64
	GetStartTime() *timestamp.Timestamp
	GetName() string
}
type Out_MySpanner_SetNameAsdf interface {
}
type Row_MySpanner_SetNameAsdf struct {
	item Out_MySpanner_SetNameAsdf
	err  error
}

func newRowMySpannerSetNameAsdf(item Out_MySpanner_SetNameAsdf, err error) *Row_MySpanner_SetNameAsdf {
	return &Row_MySpanner_SetNameAsdf{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_MySpanner_SetNameAsdf) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*test.NumRows); ok {
		if o == nil {
			return fmt.Errorf("must initialize *test.NumRows before giving to Unwrap()")
		}
		res, _ := this.TestNumRows()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_MySpanner_SetNameAsdf) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_MySpanner_SetNameAsdf) TestNumRows() (*test.NumRows, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &test.NumRows{}, nil
}

func (this *Row_MySpanner_SetNameAsdf) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type Hooks_MySpanner interface {
	UniarySelectWithHooksBeforeHook(context.Context, *test.ExampleTable) (*test.ExampleTable, error)
	ServerStreamWithHooksBeforeHook(context.Context, *test.Name) (*test.ExampleTable, error)
	ClientStreamUpdateWithHooksBeforeHook(context.Context, *test.ExampleTable) (*test.NumRows, error)
	UniarySelectWithHooksAfterHook(context.Context, *test.ExampleTable, *test.ExampleTable) error
	ServerStreamWithHooksAfterHook(context.Context, *test.Name, *test.ExampleTable) error
	ClientStreamUpdateWithHooksAfterHook(context.Context, *test.ExampleTable, *test.NumRows) error
}
type DefaultHooks_MySpanner struct{}

func (*DefaultHooks_MySpanner) UniarySelectWithHooksBeforeHook(context.Context, *test.ExampleTable) (*test.ExampleTable, error) {
	return nil, nil
}
func (*DefaultHooks_MySpanner) ServerStreamWithHooksBeforeHook(context.Context, *test.Name) (*test.ExampleTable, error) {
	return nil, nil
}
func (*DefaultHooks_MySpanner) ClientStreamUpdateWithHooksBeforeHook(context.Context, *test.ExampleTable) (*test.NumRows, error) {
	return nil, nil
}
func (*DefaultHooks_MySpanner) UniarySelectWithHooksAfterHook(context.Context, *test.ExampleTable, *test.ExampleTable) error {
	return nil
}
func (*DefaultHooks_MySpanner) ServerStreamWithHooksAfterHook(context.Context, *test.Name, *test.ExampleTable) error {
	return nil
}
func (*DefaultHooks_MySpanner) ClientStreamUpdateWithHooksAfterHook(context.Context, *test.ExampleTable, *test.NumRows) error {
	return nil
}

type TypeMappings_MySpanner interface {
	TimestampTimestamp() MappingImpl_MySpanner_TimestampTimestamp
}
type DefaultTypeMappings_MySpanner struct{}

func (this *DefaultTypeMappings_MySpanner) TimestampTimestamp() MappingImpl_MySpanner_TimestampTimestamp {
	return &DefaultMappingImpl_MySpanner_TimestampTimestamp{}
}

type DefaultMappingImpl_MySpanner_TimestampTimestamp struct{}

func (this *DefaultMappingImpl_MySpanner_TimestampTimestamp) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *DefaultMappingImpl_MySpanner_TimestampTimestamp) ToSpanner(*timestamp.Timestamp) persist.SpannerScanValuer {
	return this
}
func (this *DefaultMappingImpl_MySpanner_TimestampTimestamp) SpannerScan(*spanner.GenericColumnValue) error {
	return nil
}
func (this *DefaultMappingImpl_MySpanner_TimestampTimestamp) SpannerValue() (interface{}, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_MySpanner_TimestampTimestamp interface {
	ToProto(**timestamp.Timestamp) error
	ToSpanner(*timestamp.Timestamp) persist.SpannerScanValuer
	SpannerScan(*spanner.GenericColumnValue) error
	SpannerValue() (interface{}, error)
}

type Opts_MySpanner struct {
	MAPPINGS TypeMappings_MySpanner
	HOOKS    Hooks_MySpanner
}

func OptsMySpanner(hooks Hooks_MySpanner, mappings TypeMappings_MySpanner) Opts_MySpanner {
	opts := Opts_MySpanner{
		HOOKS:    &DefaultHooks_MySpanner{},
		MAPPINGS: &DefaultTypeMappings_MySpanner{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_MySpanner struct {
	opts     *Opts_MySpanner
	QUERIES  *Queries_MySpanner
	HANDLERS RestOfHandlers_MySpanner
	DB       *spanner.Client
}

func ImplMySpanner(db *spanner.Client, handlers RestOfHandlers_MySpanner, opts ...Opts_MySpanner) *Impl_MySpanner {
	var myOpts Opts_MySpanner
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsMySpanner(&DefaultHooks_MySpanner{}, &DefaultTypeMappings_MySpanner{})
	}
	return &Impl_MySpanner{
		opts:     &myOpts,
		QUERIES:  QueriesMySpanner(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_MySpanner interface {
}

func (this *Impl_MySpanner) UniaryInsert(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	query := this.QUERIES.Insert(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &test.ExampleTable{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_MySpanner) UniarySelect(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	query := this.QUERIES.Select(ctx, this.DB.Single())

	result := query.Execute(req)
	res, err := result.One().TestExampleTable()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_MySpanner) UniarySelectWithDirectives(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	query := this.QUERIES.SelectIndex(ctx, this.DB.Single())

	result := query.Execute(req)
	res, err := result.One().TestExampleTable()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_MySpanner) UniaryUpdate(ctx context.Context, req *test.ExampleTable) (*test.PartialTable, error) {
	query := this.QUERIES.Update(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &test.PartialTable{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_MySpanner) UniaryDeleteRange(ctx context.Context, req *test.ExampleTableRange) (*test.ExampleTable, error) {
	query := this.QUERIES.Delete(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &test.ExampleTable{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_MySpanner) ServerStream(req *test.Name, stream MySpanner_ServerStreamServer) error {
	if err := this.ServerStreamTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'select_all' query: %v", err)
	}
	return nil
}
func (this *Impl_MySpanner) ServerStreamTx(req *test.Name, stream MySpanner_ServerStreamServer, tx persist.SpannerRunnable) error {
	ctx := stream.Context()
	query := this.QUERIES.SelectAll(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_MySpanner_SelectAll) error {
		res, err := row.TestExampleTable()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_MySpanner) ClientStreamInsert(stream MySpanner_ClientStreamInsertServer) error {
	if err := this.ClientStreamInsertTx(stream); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'insert_3' query: %v", err)
	}
	return nil
}
func (this *Impl_MySpanner) ClientStreamInsertTx(stream MySpanner_ClientStreamInsertServer) error {
	items := make([]*test.ExampleTable, 0)
	var first *test.ExampleTable
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		items = append(items, req)
	}
	_, err := this.DB.ReadWriteTransaction(stream.Context(), func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
		for _, item := range items {
			query := this.QUERIES.Insert_3(ctx, tx)
			result := query.Execute(item)
			if err := result.Zero(); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in read write transaction: %v", err)
	}
	res := &test.NumRows{}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

func (this *Impl_MySpanner) ClientStreamDelete(stream MySpanner_ClientStreamDeleteServer) error {
	if err := this.ClientStreamDeleteTx(stream); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'delete_id' query: %v", err)
	}
	return nil
}
func (this *Impl_MySpanner) ClientStreamDeleteTx(stream MySpanner_ClientStreamDeleteServer) error {
	items := make([]*test.ExampleTable, 0)
	var first *test.ExampleTable
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		items = append(items, req)
	}
	_, err := this.DB.ReadWriteTransaction(stream.Context(), func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
		for _, item := range items {
			query := this.QUERIES.DeleteId(ctx, tx)
			result := query.Execute(item)
			if err := result.Zero(); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in read write transaction: %v", err)
	}
	res := &test.NumRows{}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

func (this *Impl_MySpanner) UniarySelectWithHooks(ctx context.Context, req *test.ExampleTable) (*test.ExampleTable, error) {
	query := this.QUERIES.SelectIndex(ctx, this.DB.Single())

	beforeRes, err := this.opts.HOOKS.UniarySelectWithHooksBeforeHook(ctx, req)
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
	} else if beforeRes != nil {
		return beforeRes, nil
	}

	result := query.Execute(req)
	res, err := result.One().TestExampleTable()
	if err != nil {
		return nil, err
	}

	{
		if err := this.opts.HOOKS.UniarySelectWithHooksAfterHook(ctx, req, res); err != nil {
			return nil, gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
		}
	}

	return res, nil
}

func (this *Impl_MySpanner) ServerStreamWithHooks(req *test.Name, stream MySpanner_ServerStreamWithHooksServer) error {
	if err := this.ServerStreamWithHooksTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'select_all' query: %v", err)
	}
	return nil
}
func (this *Impl_MySpanner) ServerStreamWithHooksTx(req *test.Name, stream MySpanner_ServerStreamWithHooksServer, tx persist.SpannerRunnable) error {
	ctx := stream.Context()
	query := this.QUERIES.SelectAll(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_MySpanner_SelectAll) error {
		res, err := row.TestExampleTable()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_MySpanner) ClientStreamUpdateWithHooks(stream MySpanner_ClientStreamUpdateWithHooksServer) error {
	if err := this.ClientStreamUpdateWithHooksTx(stream); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'set_name_asdf' query: %v", err)
	}
	return nil
}
func (this *Impl_MySpanner) ClientStreamUpdateWithHooksTx(stream MySpanner_ClientStreamUpdateWithHooksServer) error {
	items := make([]*test.ExampleTable, 0)
	var first *test.ExampleTable
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		{
			beforeRes, err := this.opts.HOOKS.ClientStreamUpdateWithHooksBeforeHook(stream.Context(), req)
			if err != nil {
				return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
			} else if beforeRes != nil {
				continue
			}
		}

		items = append(items, req)
	}
	_, err := this.DB.ReadWriteTransaction(stream.Context(), func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
		for _, item := range items {
			query := this.QUERIES.SetNameAsdf(ctx, tx)
			result := query.Execute(item)
			if err := result.Zero(); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in read write transaction: %v", err)
	}
	res := &test.NumRows{}

	{
		if err := this.opts.HOOKS.ClientStreamUpdateWithHooksAfterHook(stream.Context(), first, res); err != nil {
			return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
		}
	}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}
