// This file is generated by protoc-gen-persist
// Source File: tests/sql/little_of_everything/little_of_everything.proto
// DO NOT EDIT !
package little_of_everything

import (
	sql "database/sql"
	driver "database/sql/driver"
	fmt "fmt"
	io "io"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	persist "github.com/tcncloud/protoc-gen-persist/persist"
	test "github.com/tcncloud/protoc-gen-persist/tests/test"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

func NopPersistTx(r persist.Runnable) (persist.PersistTx, error) {
	return &ignoreTx{r}, nil
}

type ignoreTx struct {
	r persist.Runnable
}

func (this *ignoreTx) Commit() error   { return nil }
func (this *ignoreTx) Rollback() error { return nil }
func (this *ignoreTx) QueryContext(ctx context.Context, x string, ys ...interface{}) (*sql.Rows, error) {
	return this.r.QueryContext(ctx, x, ys...)
}
func (this *ignoreTx) ExecContext(ctx context.Context, x string, ys ...interface{}) (sql.Result, error) {
	return this.r.ExecContext(ctx, x, ys...)
}

type Runnable interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func DefaultClientStreamingPersistTx(ctx context.Context, db *sql.DB) (persist.PersistTx, error) {
	return db.BeginTx(ctx, nil)
}
func DefaultServerStreamingPersistTx(ctx context.Context, db *sql.DB) (persist.PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultBidiStreamingPersistTx(ctx context.Context, db *sql.DB) (persist.PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultUnaryPersistTx(ctx context.Context, db *sql.DB) (persist.PersistTx, error) {
	return NopPersistTx(db)
}

type alwaysScanner struct {
	i *interface{}
}

func (s *alwaysScanner) Scan(src interface{}) error {
	s.i = &src
	return nil
}

type scanable interface {
	Scan(...interface{}) error
	Columns() ([]string, error)
}

// Queries_Testservice1 holds all the queries found the proto service option as methods
type Queries_Testservice1 struct {
	opts Opts_Testservice1
}

// QueriesTestservice1 returns all the known 'SQL' queires for the 'Testservice1' service.
// If no opts are provided default implementations are used.
func QueriesTestservice1(opts ...Opts_Testservice1) *Queries_Testservice1 {
	var myOpts Opts_Testservice1
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsTestservice1(&DefaultHooks_Testservice1{}, &DefaultTypeMappings_Testservice1{})
	}
	return &Queries_Testservice1{
		opts: myOpts,
	}
}

// UnaryExample1 returns a struct that will perform the 'unary_example1' query.
// When Execute is called, it will use the following fields:
// [table_id]
func (this *Queries_Testservice1) UnaryExample1(ctx context.Context, db persist.Runnable) *Query_Testservice1_UnaryExample1 {
	return &Query_Testservice1_UnaryExample1{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_Testservice1_UnaryExample1 (future doc string needed)
type Query_Testservice1_UnaryExample1 struct {
	opts Opts_Testservice1
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_Testservice1_UnaryExample1) QueryInType_ExampleTable1()  {}
func (this *Query_Testservice1_UnaryExample1) QueryOutType_ExampleTable1() {}

// Executes the query 'unary_example1' with parameters retrieved from x.
// Fields used: [table_id]
func (this *Query_Testservice1_UnaryExample1) Execute(x In_Testservice1_UnaryExample1) *Iter_Testservice1_UnaryExample1 {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetTableId()
			return
		}(),
	}
	result := &Iter_Testservice1_UnaryExample1{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id AS 'table_key', id, value, msg as inner_message, status as inner_enum FROM test_table WHERE id = $1", params...)
	return result
}

// UnaryExample2 returns a struct that will perform the 'unary_example2' query.
// When Execute is called, it will use the following fields:
// [id]
func (this *Queries_Testservice1) UnaryExample2(ctx context.Context, db persist.Runnable) *Query_Testservice1_UnaryExample2 {
	return &Query_Testservice1_UnaryExample2{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_Testservice1_UnaryExample2 (future doc string needed)
type Query_Testservice1_UnaryExample2 struct {
	opts Opts_Testservice1
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_Testservice1_UnaryExample2) QueryInType_Test()           {}
func (this *Query_Testservice1_UnaryExample2) QueryOutType_ExampleTable1() {}

// Executes the query 'unary_example2' with parameters retrieved from x.
// Fields used: [id]
func (this *Query_Testservice1_UnaryExample2) Execute(x In_Testservice1_UnaryExample2) *Iter_Testservice1_UnaryExample2 {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
	}
	result := &Iter_Testservice1_UnaryExample2{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id AS 'table_id', key, value, msg as inner_message, status as inner_enum FROM test_table WHERE id = $1", params...)
	return result
}

// ServerStreamSelect returns a struct that will perform the 'server_stream_select' query.
// When Execute is called, it will use the following fields:
// [table_id]
func (this *Queries_Testservice1) ServerStreamSelect(ctx context.Context, db persist.Runnable) *Query_Testservice1_ServerStreamSelect {
	return &Query_Testservice1_ServerStreamSelect{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_Testservice1_ServerStreamSelect (future doc string needed)
type Query_Testservice1_ServerStreamSelect struct {
	opts Opts_Testservice1
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_Testservice1_ServerStreamSelect) QueryInType_ExampleTable1()  {}
func (this *Query_Testservice1_ServerStreamSelect) QueryOutType_ExampleTable1() {}

// Executes the query 'server_stream_select' with parameters retrieved from x.
// Fields used: [table_id]
func (this *Query_Testservice1_ServerStreamSelect) Execute(x In_Testservice1_ServerStreamSelect) *Iter_Testservice1_ServerStreamSelect {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetTableId()
			return
		}(),
	}
	result := &Iter_Testservice1_ServerStreamSelect{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.rows, result.err = this.db.QueryContext(this.ctx, "SELECT id AS 'table_id', key, value, msg as inner_message, status as inner_enum FROM test_table WHERE id = $1", params...)
	return result
}

// ClientStreamingExample returns a struct that will perform the 'client_streaming_example' query.
// When Execute is called, it will use the following fields:
// [table_id]
func (this *Queries_Testservice1) ClientStreamingExample(ctx context.Context, db persist.Runnable) *Query_Testservice1_ClientStreamingExample {
	return &Query_Testservice1_ClientStreamingExample{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

// Query_Testservice1_ClientStreamingExample (future doc string needed)
type Query_Testservice1_ClientStreamingExample struct {
	opts Opts_Testservice1
	db   persist.Runnable
	ctx  context.Context
}

func (this *Query_Testservice1_ClientStreamingExample) QueryInType_ExampleTable1() {}
func (this *Query_Testservice1_ClientStreamingExample) QueryOutType_Empty()        {}

// Executes the query 'client_streaming_example' with parameters retrieved from x.
// Fields used: [table_id]
func (this *Query_Testservice1_ClientStreamingExample) Execute(x In_Testservice1_ClientStreamingExample) *Iter_Testservice1_ClientStreamingExample {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetTableId()
			return
		}(),
	}
	result := &Iter_Testservice1_ClientStreamingExample{
		tm:  this.opts.MAPPINGS,
		ctx: this.ctx,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.db.ExecContext(this.ctx, "SELECT id AS 'table_id', key, value, msg as inner_message, status as inner_enum FROM test_table WHERE id = $1", params...)
	return result
}

type Iter_Testservice1_UnaryExample1 struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_Testservice1
	ctx    context.Context
}

func (this *Iter_Testservice1_UnaryExample1) IterOutTypeExampleTable1() {}
func (this *Iter_Testservice1_UnaryExample1) IterInTypeExampleTable1()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_Testservice1_UnaryExample1) Each(fun func(*Row_Testservice1_UnaryExample1) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_Testservice1_UnaryExample1) One() *Row_Testservice1_UnaryExample1 {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_Testservice1_UnaryExample1{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("expected exactly 1 result from query 'UnaryExample1' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_Testservice1_UnaryExample1) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UnaryExample1'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_Testservice1_UnaryExample1) Next() (*Row_Testservice1_UnaryExample1, bool) {
	if this.err != io.EOF && this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_Testservice1_UnaryExample1{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_Testservice1_UnaryExample1{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_Testservice1_UnaryExample1{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_Testservice1_UnaryExample1{err: this.err}, true
	}
	res := &ExampleTable1{}
	for i, col := range cols {
		_ = i
		switch col {
		case "table_id":
			r, ok := (*scanned[i].i).(int32)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column table_id to protobuf go type ")}, true
			}
			res.TableId = r
		case "key":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column key to protobuf go type ")}, true
			}
			res.Key = r
		case "value":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column value to protobuf go type ")}, true
			}
			res.Value = r
		case "inner_message":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column inner_message to protobuf go type *ExampleTable1_InnerMessage")}, true
			}
			var converted = new(ExampleTable1_InnerMessage)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_UnaryExample1{err: err}, true
			}
			res.InnerMessage = converted
		case "inner_enum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column inner_enum to protobuf go type *ExampleTable1_InnerEnum")}, true
			}
			var converted = (ExampleTable1_InnerEnum)(int32(r))
			res.InnerEnum = converted
		case "string_array":
			r, ok := (*scanned[i].i).([]string)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column string_array to protobuf go type ")}, true
			}
			res.StringArray = r
		case "bytes_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column bytes_field to protobuf go type ")}, true
			}
			res.BytesField = r
		case "start_time":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("could not convert mapped db column start_time to type on ExampleTable1.StartTime: %v", err)}, true
			}
			if err := converted.ToProto(&res.StartTime); err != nil {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("could not convert mapped db column start_timeto type on ExampleTable1.StartTime: %v", err)}, true
			}
		case "test_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column test_field to protobuf go type *test.Test")}, true
			}
			var converted = new(test.Test)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_UnaryExample1{err: err}, true
			}
			res.TestField = converted
		case "myyenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column myyenum to protobuf go type *MyEnum")}, true
			}
			var converted = (MyEnum)(int32(r))
			res.Myyenum = converted
		case "testsenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("cant convert db column testsenum to protobuf go type *test.TestEnum")}, true
			}
			var converted = (test.TestEnum)(int32(r))
			res.Testsenum = converted
		case "mappedenum":
			var converted = this.tm.MappedEnum()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("could not convert mapped db column mappedenum to type on ExampleTable1.Mappedenum: %v", err)}, true
			}
			pToRes := &res.Mappedenum
			if err := converted.ToProto(&pToRes); err != nil {
				return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("could not convert mapped db column mappedenumto type on ExampleTable1.Mappedenum: %v", err)}, true
			}

		default:
			return &Row_Testservice1_UnaryExample1{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_Testservice1_UnaryExample1{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_Testservice1_UnaryExample1) Slice() []*Row_Testservice1_UnaryExample1 {
	var results []*Row_Testservice1_UnaryExample1
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_Testservice1_UnaryExample1) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_Testservice1_UnaryExample2 struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_Testservice1
	ctx    context.Context
}

func (this *Iter_Testservice1_UnaryExample2) IterOutTypeExampleTable1() {}
func (this *Iter_Testservice1_UnaryExample2) IterInTypeTestTest()       {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_Testservice1_UnaryExample2) Each(fun func(*Row_Testservice1_UnaryExample2) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_Testservice1_UnaryExample2) One() *Row_Testservice1_UnaryExample2 {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_Testservice1_UnaryExample2{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("expected exactly 1 result from query 'UnaryExample2' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_Testservice1_UnaryExample2) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UnaryExample2'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_Testservice1_UnaryExample2) Next() (*Row_Testservice1_UnaryExample2, bool) {
	if this.err != io.EOF && this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_Testservice1_UnaryExample2{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_Testservice1_UnaryExample2{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_Testservice1_UnaryExample2{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_Testservice1_UnaryExample2{err: this.err}, true
	}
	res := &ExampleTable1{}
	for i, col := range cols {
		_ = i
		switch col {
		case "table_id":
			r, ok := (*scanned[i].i).(int32)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column table_id to protobuf go type ")}, true
			}
			res.TableId = r
		case "key":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column key to protobuf go type ")}, true
			}
			res.Key = r
		case "value":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column value to protobuf go type ")}, true
			}
			res.Value = r
		case "inner_message":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column inner_message to protobuf go type *ExampleTable1_InnerMessage")}, true
			}
			var converted = new(ExampleTable1_InnerMessage)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_UnaryExample2{err: err}, true
			}
			res.InnerMessage = converted
		case "inner_enum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column inner_enum to protobuf go type *ExampleTable1_InnerEnum")}, true
			}
			var converted = (ExampleTable1_InnerEnum)(int32(r))
			res.InnerEnum = converted
		case "string_array":
			r, ok := (*scanned[i].i).([]string)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column string_array to protobuf go type ")}, true
			}
			res.StringArray = r
		case "bytes_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column bytes_field to protobuf go type ")}, true
			}
			res.BytesField = r
		case "start_time":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("could not convert mapped db column start_time to type on ExampleTable1.StartTime: %v", err)}, true
			}
			if err := converted.ToProto(&res.StartTime); err != nil {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("could not convert mapped db column start_timeto type on ExampleTable1.StartTime: %v", err)}, true
			}
		case "test_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column test_field to protobuf go type *test.Test")}, true
			}
			var converted = new(test.Test)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_UnaryExample2{err: err}, true
			}
			res.TestField = converted
		case "myyenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column myyenum to protobuf go type *MyEnum")}, true
			}
			var converted = (MyEnum)(int32(r))
			res.Myyenum = converted
		case "testsenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("cant convert db column testsenum to protobuf go type *test.TestEnum")}, true
			}
			var converted = (test.TestEnum)(int32(r))
			res.Testsenum = converted
		case "mappedenum":
			var converted = this.tm.MappedEnum()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("could not convert mapped db column mappedenum to type on ExampleTable1.Mappedenum: %v", err)}, true
			}
			pToRes := &res.Mappedenum
			if err := converted.ToProto(&pToRes); err != nil {
				return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("could not convert mapped db column mappedenumto type on ExampleTable1.Mappedenum: %v", err)}, true
			}

		default:
			return &Row_Testservice1_UnaryExample2{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_Testservice1_UnaryExample2{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_Testservice1_UnaryExample2) Slice() []*Row_Testservice1_UnaryExample2 {
	var results []*Row_Testservice1_UnaryExample2
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_Testservice1_UnaryExample2) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_Testservice1_ServerStreamSelect struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_Testservice1
	ctx    context.Context
}

func (this *Iter_Testservice1_ServerStreamSelect) IterOutTypeExampleTable1() {}
func (this *Iter_Testservice1_ServerStreamSelect) IterInTypeExampleTable1()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_Testservice1_ServerStreamSelect) Each(fun func(*Row_Testservice1_ServerStreamSelect) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_Testservice1_ServerStreamSelect) One() *Row_Testservice1_ServerStreamSelect {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_Testservice1_ServerStreamSelect{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("expected exactly 1 result from query 'ServerStreamSelect' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_Testservice1_ServerStreamSelect) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ServerStreamSelect'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_Testservice1_ServerStreamSelect) Next() (*Row_Testservice1_ServerStreamSelect, bool) {
	if this.err != io.EOF && this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_Testservice1_ServerStreamSelect{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_Testservice1_ServerStreamSelect{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_Testservice1_ServerStreamSelect{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_Testservice1_ServerStreamSelect{err: this.err}, true
	}
	res := &ExampleTable1{}
	for i, col := range cols {
		_ = i
		switch col {
		case "table_id":
			r, ok := (*scanned[i].i).(int32)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column table_id to protobuf go type ")}, true
			}
			res.TableId = r
		case "key":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column key to protobuf go type ")}, true
			}
			res.Key = r
		case "value":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column value to protobuf go type ")}, true
			}
			res.Value = r
		case "inner_message":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column inner_message to protobuf go type *ExampleTable1_InnerMessage")}, true
			}
			var converted = new(ExampleTable1_InnerMessage)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: err}, true
			}
			res.InnerMessage = converted
		case "inner_enum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column inner_enum to protobuf go type *ExampleTable1_InnerEnum")}, true
			}
			var converted = (ExampleTable1_InnerEnum)(int32(r))
			res.InnerEnum = converted
		case "string_array":
			r, ok := (*scanned[i].i).([]string)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column string_array to protobuf go type ")}, true
			}
			res.StringArray = r
		case "bytes_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column bytes_field to protobuf go type ")}, true
			}
			res.BytesField = r
		case "start_time":
			var converted = this.tm.TimestampTimestamp()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("could not convert mapped db column start_time to type on ExampleTable1.StartTime: %v", err)}, true
			}
			if err := converted.ToProto(&res.StartTime); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("could not convert mapped db column start_timeto type on ExampleTable1.StartTime: %v", err)}, true
			}
		case "test_field":
			r, ok := (*scanned[i].i).([]byte)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column test_field to protobuf go type *test.Test")}, true
			}
			var converted = new(test.Test)
			if err := proto.Unmarshal(r, converted); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: err}, true
			}
			res.TestField = converted
		case "myyenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column myyenum to protobuf go type *MyEnum")}, true
			}
			var converted = (MyEnum)(int32(r))
			res.Myyenum = converted
		case "testsenum":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("cant convert db column testsenum to protobuf go type *test.TestEnum")}, true
			}
			var converted = (test.TestEnum)(int32(r))
			res.Testsenum = converted
		case "mappedenum":
			var converted = this.tm.MappedEnum()
			if err := converted.Scan(*scanned[i].i); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("could not convert mapped db column mappedenum to type on ExampleTable1.Mappedenum: %v", err)}, true
			}
			pToRes := &res.Mappedenum
			if err := converted.ToProto(&pToRes); err != nil {
				return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("could not convert mapped db column mappedenumto type on ExampleTable1.Mappedenum: %v", err)}, true
			}

		default:
			return &Row_Testservice1_ServerStreamSelect{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_Testservice1_ServerStreamSelect{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_Testservice1_ServerStreamSelect) Slice() []*Row_Testservice1_ServerStreamSelect {
	var results []*Row_Testservice1_ServerStreamSelect
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_Testservice1_ServerStreamSelect) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type Iter_Testservice1_ClientStreamingExample struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     TypeMappings_Testservice1
	ctx    context.Context
}

func (this *Iter_Testservice1_ClientStreamingExample) IterOutTypeEmpty()        {}
func (this *Iter_Testservice1_ClientStreamingExample) IterInTypeExampleTable1() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *Iter_Testservice1_ClientStreamingExample) Each(fun func(*Row_Testservice1_ClientStreamingExample) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *Iter_Testservice1_ClientStreamingExample) One() *Row_Testservice1_ClientStreamingExample {
	first, hasFirst := this.Next()
	if first != nil && first.err != nil && first.err != io.EOF {
		return &Row_Testservice1_ClientStreamingExample{err: first.err}
	}
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &Row_Testservice1_ClientStreamingExample{err: fmt.Errorf("expected exactly 1 result from query 'ClientStreamingExample' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *Iter_Testservice1_ClientStreamingExample) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil && row.err != io.EOF {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'ClientStreamingExample'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *Iter_Testservice1_ClientStreamingExample) Next() (*Row_Testservice1_ClientStreamingExample, bool) {
	if this.err != io.EOF && this.err != nil {
		err := this.err
		this.err = io.EOF
		return &Row_Testservice1_ClientStreamingExample{err: err}, true
	}
	if this.rows == nil {
		this.err = io.EOF
		return nil, false
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return &Row_Testservice1_ClientStreamingExample{err: err}, true
	}
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
			return nil, false
		} else if this.err != nil {
			return &Row_Testservice1_ClientStreamingExample{err: err}, true
		}
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return &Row_Testservice1_ClientStreamingExample{err: this.err}, true
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {

		default:
			return &Row_Testservice1_ClientStreamingExample{err: fmt.Errorf("unsupported column in output: %s", col)}, true
		}
	}
	return &Row_Testservice1_ClientStreamingExample{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *Iter_Testservice1_ClientStreamingExample) Slice() []*Row_Testservice1_ClientStreamingExample {
	var results []*Row_Testservice1_ClientStreamingExample
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

// returns the known columns for this result
func (r *Iter_Testservice1_ClientStreamingExample) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type In_Testservice1_UnaryExample1 interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Out_Testservice1_UnaryExample1 interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Row_Testservice1_UnaryExample1 struct {
	item Out_Testservice1_UnaryExample1
	err  error
}

func newRowTestservice1UnaryExample1(item Out_Testservice1_UnaryExample1, err error) *Row_Testservice1_UnaryExample1 {
	return &Row_Testservice1_UnaryExample1{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_Testservice1_UnaryExample1) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	return nil
}
func (this *Row_Testservice1_UnaryExample1) ExampleTable1() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

func (this *Row_Testservice1_UnaryExample1) Proto() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

type In_Testservice1_UnaryExample2 interface {
	GetId() int32
	GetName() string
}
type Out_Testservice1_UnaryExample2 interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Row_Testservice1_UnaryExample2 struct {
	item Out_Testservice1_UnaryExample2
	err  error
}

func newRowTestservice1UnaryExample2(item Out_Testservice1_UnaryExample2, err error) *Row_Testservice1_UnaryExample2 {
	return &Row_Testservice1_UnaryExample2{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_Testservice1_UnaryExample2) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	return nil
}
func (this *Row_Testservice1_UnaryExample2) ExampleTable1() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

func (this *Row_Testservice1_UnaryExample2) Proto() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

type In_Testservice1_ServerStreamSelect interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Out_Testservice1_ServerStreamSelect interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Row_Testservice1_ServerStreamSelect struct {
	item Out_Testservice1_ServerStreamSelect
	err  error
}

func newRowTestservice1ServerStreamSelect(item Out_Testservice1_ServerStreamSelect, err error) *Row_Testservice1_ServerStreamSelect {
	return &Row_Testservice1_ServerStreamSelect{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_Testservice1_ServerStreamSelect) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	if o, ok := (pointerToMsg).(*ExampleTable1); ok {
		if o == nil {
			return fmt.Errorf("must initialize *ExampleTable1 before giving to Unwrap()")
		}
		res, _ := this.ExampleTable1()
		_ = res
		o.TableId = res.TableId
		o.Key = res.Key
		o.Value = res.Value
		o.InnerMessage = res.InnerMessage
		o.InnerEnum = res.InnerEnum
		o.StringArray = res.StringArray
		o.BytesField = res.BytesField
		o.StartTime = res.StartTime
		o.TestField = res.TestField
		o.Myyenum = res.Myyenum
		o.Testsenum = res.Testsenum
		o.Mappedenum = res.Mappedenum
		return nil
	}

	return nil
}
func (this *Row_Testservice1_ServerStreamSelect) ExampleTable1() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

func (this *Row_Testservice1_ServerStreamSelect) Proto() (*ExampleTable1, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &ExampleTable1{
		TableId:      this.item.GetTableId(),
		Key:          this.item.GetKey(),
		Value:        this.item.GetValue(),
		InnerMessage: this.item.GetInnerMessage(),
		InnerEnum:    this.item.GetInnerEnum(),
		StringArray:  this.item.GetStringArray(),
		BytesField:   this.item.GetBytesField(),
		StartTime:    this.item.GetStartTime(),
		TestField:    this.item.GetTestField(),
		Myyenum:      this.item.GetMyyenum(),
		Testsenum:    this.item.GetTestsenum(),
		Mappedenum:   this.item.GetMappedenum(),
	}, nil
}

type In_Testservice1_ClientStreamingExample interface {
	GetTableId() int32
	GetKey() string
	GetValue() string
	GetInnerMessage() *ExampleTable1_InnerMessage
	GetInnerEnum() ExampleTable1_InnerEnum
	GetStringArray() []string
	GetBytesField() []byte
	GetStartTime() *timestamp.Timestamp
	GetTestField() *test.Test
	GetMyyenum() MyEnum
	GetTestsenum() test.TestEnum
	GetMappedenum() MappedEnum
}
type Out_Testservice1_ClientStreamingExample interface {
}
type Row_Testservice1_ClientStreamingExample struct {
	item Out_Testservice1_ClientStreamingExample
	err  error
}

func newRowTestservice1ClientStreamingExample(item Out_Testservice1_ClientStreamingExample, err error) *Row_Testservice1_ClientStreamingExample {
	return &Row_Testservice1_ClientStreamingExample{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *Row_Testservice1_ClientStreamingExample) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	if o, ok := (pointerToMsg).(*CountRows); ok {
		if o == nil {
			return fmt.Errorf("must initialize *CountRows before giving to Unwrap()")
		}
		res, _ := this.CountRows()
		_ = res

		return nil
	}

	return nil
}
func (this *Row_Testservice1_ClientStreamingExample) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}
func (this *Row_Testservice1_ClientStreamingExample) CountRows() (*CountRows, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &CountRows{}, nil
}

func (this *Row_Testservice1_ClientStreamingExample) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type Hooks_Testservice1 interface {
}
type DefaultHooks_Testservice1 struct{}
type TypeMappings_Testservice1 interface {
	TimestampTimestamp() MappingImpl_Testservice1_TimestampTimestamp
	MappedEnum() MappingImpl_Testservice1_MappedEnum
}

type DefaultTypeMappings_Testservice1 struct{}

func (this *DefaultTypeMappings_Testservice1) TimestampTimestamp() MappingImpl_Testservice1_TimestampTimestamp {
	return &DefaultMappingImpl_Testservice1_TimestampTimestamp{}
}

type DefaultMappingImpl_Testservice1_TimestampTimestamp struct{}

func (this *DefaultMappingImpl_Testservice1_TimestampTimestamp) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *DefaultMappingImpl_Testservice1_TimestampTimestamp) ToSql(*timestamp.Timestamp) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_Testservice1_TimestampTimestamp) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_Testservice1_TimestampTimestamp) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_Testservice1_TimestampTimestamp interface {
	ToProto(**timestamp.Timestamp) error
	ToSql(*timestamp.Timestamp) sql.Scanner
	sql.Scanner
	driver.Valuer
}

func (this *DefaultTypeMappings_Testservice1) MappedEnum() MappingImpl_Testservice1_MappedEnum {
	return &DefaultMappingImpl_Testservice1_MappedEnum{}
}

type DefaultMappingImpl_Testservice1_MappedEnum struct{}

func (this *DefaultMappingImpl_Testservice1_MappedEnum) ToProto(**MappedEnum) error {
	return nil
}
func (this *DefaultMappingImpl_Testservice1_MappedEnum) ToSql(*MappedEnum) sql.Scanner {
	return this
}
func (this *DefaultMappingImpl_Testservice1_MappedEnum) Scan(interface{}) error {
	return nil
}
func (this *DefaultMappingImpl_Testservice1_MappedEnum) Value() (driver.Value, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type MappingImpl_Testservice1_MappedEnum interface {
	ToProto(**MappedEnum) error
	ToSql(*MappedEnum) sql.Scanner
	sql.Scanner
	driver.Valuer
}

type Opts_Testservice1 struct {
	MAPPINGS TypeMappings_Testservice1
	HOOKS    Hooks_Testservice1
}

func OptsTestservice1(hooks Hooks_Testservice1, mappings TypeMappings_Testservice1) Opts_Testservice1 {
	opts := Opts_Testservice1{
		HOOKS:    &DefaultHooks_Testservice1{},
		MAPPINGS: &DefaultTypeMappings_Testservice1{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_Testservice1 struct {
	opts     *Opts_Testservice1
	QUERIES  *Queries_Testservice1
	HANDLERS RestOfHandlers_Testservice1
	DB       *sql.DB
}

func ImplTestservice1(db *sql.DB, handlers RestOfHandlers_Testservice1, opts ...Opts_Testservice1) *Impl_Testservice1 {
	var myOpts Opts_Testservice1
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsTestservice1(&DefaultHooks_Testservice1{}, &DefaultTypeMappings_Testservice1{})
	}
	return &Impl_Testservice1{
		opts:     &myOpts,
		QUERIES:  QueriesTestservice1(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_Testservice1 interface {
}

func (this *Impl_Testservice1) UnaryExample1(ctx context.Context, req *ExampleTable1) (*ExampleTable1, error) {
	query := this.QUERIES.UnaryExample1(ctx, this.DB)

	result := query.Execute(req)
	res, err := result.One().ExampleTable1()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_Testservice1) UnaryExample2(ctx context.Context, req *test.Test) (*ExampleTable1, error) {
	query := this.QUERIES.UnaryExample2(ctx, this.DB)

	result := query.Execute(req)
	res, err := result.One().ExampleTable1()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *Impl_Testservice1) ServerStreamSelect(req *ExampleTable1, stream Testservice1_ServerStreamSelectServer) error {
	tx, err := DefaultServerStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.ServerStreamSelectTx(req, stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'server_stream_select' query: %v", err)
	}
	return nil
}
func (this *Impl_Testservice1) ServerStreamSelectTx(req *ExampleTable1, stream Testservice1_ServerStreamSelectServer, tx persist.PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.ServerStreamSelect(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *Row_Testservice1_ServerStreamSelect) error {
		res, err := row.ExampleTable1()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *Impl_Testservice1) ClientStreamingExample(stream Testservice1_ClientStreamingExampleServer) error {
	tx, err := DefaultClientStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.ClientStreamingExampleTx(stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'client_streaming_example' query: %v", err)
	}
	return nil
}
func (this *Impl_Testservice1) ClientStreamingExampleTx(stream Testservice1_ClientStreamingExampleServer, tx persist.PersistTx) error {
	query := this.QUERIES.ClientStreamingExample(stream.Context(), tx)
	var first *ExampleTable1
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		result := query.Execute(req)
		if err := result.Zero(); err != nil {
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			return fmt.Errorf("error executing 'client_streaming_example' query :::AND COULD NOT ROLLBACK::: rollback err: %v, query err: %v", rollbackErr, err)
		}
	}
	res := &CountRows{}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

// Queries_NotEnabledService holds all the queries found the proto service option as methods
type Queries_NotEnabledService struct {
	opts Opts_NotEnabledService
}

// QueriesNotEnabledService returns all the known 'SQL' queires for the 'NotEnabledService' service.
// If no opts are provided default implementations are used.
func QueriesNotEnabledService(opts ...Opts_NotEnabledService) *Queries_NotEnabledService {
	var myOpts Opts_NotEnabledService
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsNotEnabledService(&DefaultHooks_NotEnabledService{}, &DefaultTypeMappings_NotEnabledService{})
	}
	return &Queries_NotEnabledService{
		opts: myOpts,
	}
}

type Hooks_NotEnabledService interface {
}
type DefaultHooks_NotEnabledService struct{}
type TypeMappings_NotEnabledService interface {
}
type DefaultTypeMappings_NotEnabledService struct{}

type Opts_NotEnabledService struct {
	MAPPINGS TypeMappings_NotEnabledService
	HOOKS    Hooks_NotEnabledService
}

func OptsNotEnabledService(hooks Hooks_NotEnabledService, mappings TypeMappings_NotEnabledService) Opts_NotEnabledService {
	opts := Opts_NotEnabledService{
		HOOKS:    &DefaultHooks_NotEnabledService{},
		MAPPINGS: &DefaultTypeMappings_NotEnabledService{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type Impl_NotEnabledService struct {
	opts     *Opts_NotEnabledService
	QUERIES  *Queries_NotEnabledService
	HANDLERS RestOfHandlers_NotEnabledService
	DB       *sql.DB
}

func ImplNotEnabledService(db *sql.DB, handlers RestOfHandlers_NotEnabledService, opts ...Opts_NotEnabledService) *Impl_NotEnabledService {
	var myOpts Opts_NotEnabledService
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = OptsNotEnabledService(&DefaultHooks_NotEnabledService{}, &DefaultTypeMappings_NotEnabledService{})
	}
	return &Impl_NotEnabledService{
		opts:     &myOpts,
		QUERIES:  QueriesNotEnabledService(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfHandlers_NotEnabledService interface {
}
